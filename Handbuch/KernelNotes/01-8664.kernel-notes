@kernel-nr: 01        (info: nutze kernel lex und kernelx 01-01)
#####################################################################
@kernel-zeilen-nr:-01-01
#####################################################################
## Lektion 1: Was sind Register? Und warum sie wichtig sind.
##
## Dieses Kapitel erklÃ¤rt, wie und warum Prozessor-Register
## in x86_64-Systemen aufgebaut sind. Wir fokussieren uns auf
## die 16 Hauptregister, wie sie unter Linux, Windows, macOS
## und anderen modernen 64-Bit-Betriebssystemen verwendet werden.
##
## ------------------------
## ğŸ§  Was ist ein Register?
## ------------------------
##
## Register sind ultrakurze SpeicherplÃ¤tze direkt im Prozessor.
## Jede CPU hat davon eine feste Menge â€“ sie sind die "HÃ¤nde"
## und "Taschen" des Prozessors, wenn er arbeitet:
##
##  - Werte merken
##  - ZwischenstÃ¤nde speichern
##  - Adressen halten
##  - Rechenoperationen durchfÃ¼hren
##
## Je schneller der Zugriff, desto nÃ¤her am "Kopf" â€“ und Register
## sind direkt im Kopf (also im Chip) drin.
##
## ------------------------
## ğŸ“œ Woher kommt das Konzept?
## ------------------------
##
## FrÃ¼her (z.â€¯B. im 8086) hatte man 8 Basisregister:
##  AX, BX, CX, DX, SI, DI, BP, SP
##
## Mit x86_64 (also 64-Bit-Erweiterung durch AMD) kam:
##  - 8 weitere allgemeine Register: R8â€“R15
##  - Alle Register wurden auf 64â€¯Bit erweitert: z.â€¯B. AX â†’ RAX
##  - Der PrÃ¤fix "R" zeigt 64-Bit an
##
## Heute haben wir also 16 allgemeine Register:
##
##   RAX, RBX, RCX, RDX
##   RSI, RDI, RBP, RSP
##   R8,  R9,  R10, R11
##   R12, R13, R14, R15
##
## Dazu kommen Spezialregister (Flags, RIP, Segmentregister etc.),
## aber diese behandeln wir spÃ¤ter.
##
## ------------------------
## ğŸ”„ Wer benutzt das so?
## ------------------------
##
## Die Architektur â€x86_64â€œ (auch AMD64 genannt) ist Standard fÃ¼r:
##
##  - Linux-Systeme (Debian, Arch, Red Hat, etc.)
##  - Windows (ab XP 64â€¯Bit bis heute)
##  - macOS (bis M1 â€“ danach ARM64)
##
## Alle halten sich an diese 16 Register, wenn ein 64-Bit-Modus aktiv
## ist.
##
## ------------------------
## ğŸ§© Warum ist das wichtig fÃ¼r Pylovara?
## ------------------------
##
## Wenn wir irgendwann direkten Maschinencode (MCS) bauen wollen,
## mÃ¼ssen wir wissen, wie der Prozessor "denkt" â€“ und der denkt
## in Registern, nicht in Variablen.
##
## Register sind die **kleinste echte Sprache**, die der Prozessor
## spricht.
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-02: RAX und Familie
##  â†’ 01-03: Was macht RSP, RBP?
##  â†’ 01-04: Welche Rolle spielt RIP?
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-02
#####################################################################
## Lektion 2: RAX, RBX, RCX, RDX â€“ die Hauptregister der CPU
##
## Diese vier Die Arbeitstiere (Register)stammen direkt aus
## der Urzeit der x86-Architektur (8086) und haben Ã¼berlebt
## â€“ weil sie universell einsetzbar sind und in fast jedem
## Assembly-Code vorkommen.
##
## ------------------------
## ğŸ§± Aufbau und Namenslogik
## ------------------------
##
##  - AX â†’ RAX  = Accumulator (Rechenregister)
##  - BX â†’ RBX  = Base (Grundwert / Zeiger)
##  - CX â†’ RCX  = Counter (ZÃ¤hlregister)
##  - DX â†’ RDX  = Data (I/O-Register, Zwischenablage)
##
## Der Wechsel auf 64-Bit bringt den PrÃ¤fix â€Râ€œ, also:
##
##   AX   â†’   EAX   â†’   RAX
##   BX   â†’   EBX   â†’   RBX
##   ...
##
## Diese Register lassen sich auch in Teilen ansprechen:
##
##   RAX = 64 Bit
##   EAX = untere 32 Bit
##   AX  = untere 16 Bit
##   AL  = untere 8 Bit
##
## Beispiel:
##   mov rax, 0x12345678
##   â†’ danach ist eax = 0x12345678
##     ax  = 0x5678
##     al  = 0x78
##
## ------------------------
## ğŸ›  Was tun die Dinger?
## ------------------------
##
## Diese Register haben keine â€festenâ€œ Aufgaben mehr,
## kÃ¶nnen also frei verwendet werden â€“ aber:
##
##  - **RAX** â†’ Ergebnisregister (z.â€¯B. RÃ¼ckgabewert bei Funktionen)
##
##  - **RBX** â†’ beliebig nutzbar
##
##  - **RCX** â†’ oft ZÃ¤hler in Schleifen (LOOP, REP)
##
##  - **RDX** â†’ oft fÃ¼r Division, oder fÃ¼r Funktionen mit
##              2 RÃ¼ckgabewerten
##
## ------------------------
## ğŸ” Beispiel in Maschinensprache
## ------------------------
##
##   add rax, rbx   ; RAX = RAX + RBX
##   loop:          ; RCX = ZÃ¤hler
##     dec rcx
##     jnz loop     ; Springe zurÃ¼ck, solange RCX â‰  0
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Diese vier Register tauchen Ã¼berall auf â€“ im Kernelcode,
## bei Systemcalls, in Bootloadern, bei BIOS/UEFI, beim Debugging.
##
## Deshalb: Wer Pylovara mit SystemnÃ¤he aufbaut, muss diese
## vier gut kennen wie Familienmitglieder.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-03: RSP, RBP â€“ Der Stack und seine WÃ¤chter
##  â†’ 01-04: RIP â€“ Der ProgrammzÃ¤hler
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-03
#####################################################################
## Lektion 3: RSP, RBP â€“ Der Stack und seine WÃ¤chter
##
## Zwei der wichtigsten Register im tÃ¤glichen Systembetrieb sind
## der **Stack Pointer (RSP)** und der **Base Pointer (RBP)**.
## Ohne sie funktioniert kein Funktionsaufruf, kein RÃ¼cksprung,
## kein lokaler Speicher â€“ sie sind die WirbelsÃ¤ule jedes Programms.
##
## ------------------------
## ğŸ§± Was ist der Stack?
## ------------------------
##
## Der Stack ist ein Bereich im Arbeitsspeicher, der â€von oben
## nach untenâ€œ wÃ¤chst. Er speichert temporÃ¤re Daten wie:
##
##   - RÃ¼cksprungadressen bei Funktionsaufrufen
##   - lokale Variablen innerhalb von Funktionen
##   - gespeicherte Register (Push/Pop)
##
## ------------------------
## ğŸ“ Rolle von RSP
## ------------------------
##
## RSP = Stack Pointer
## â†’ Zeigt **immer** auf das oberste Element des Stacks.
## â†’ Wird bei `push`, `pop`, `call`, `ret` automatisch verÃ¤ndert
##
## Wenn ein Wert auf den Stack kommt (`push`), wird RSP kleiner.
## Wenn ein Wert heruntergenommen wird (`pop`), wird RSP grÃ¶ÃŸer.
##
##   push rax    ; RSP -= 8 â†’ Wert liegt auf [RSP]
##   pop rax     ; Wert von [RSP] â†’ RAX, dann RSP += 8
##
## RSP verÃ¤ndert sich bei fast jedem Funktionsaufruf.
##
## ------------------------
## ğŸ“Œ Rolle von RBP
## ------------------------
##
## RBP = Base Pointer
## â†’ Dient als **Referenzanker** innerhalb von Funktionen.
##
## Meist wird bei Funktionsbeginn gespeichert:
##
##   push rbp          ; alten Basiswert sichern
##   mov rbp, rsp      ; RBP zeigt nun auf Stack-Basis der Funktion
##
## So kann man in der Funktion gezielt lokale Variablen
## Ã¼ber relative Adressen wie `[rbp-0x10]` ansprechen.
##
## Am Ende wird RBP wiederhergestellt:
##
##   mov rsp, rbp
##   pop rbp
##   ret
##
## ------------------------
## ğŸ” Sicherheit und Debugging
## ------------------------
##
## Der Stack ist kritisch fÃ¼r Sicherheit:
##
##   - Buffer Overflows zielen auf RBP/RSP und RÃ¼cksprungadressen
##   - Debugger (wie GDB) zeigen mit RBP den Stack Frame
##
## Deshalb: wer den Stack versteht, versteht das Herz des Programms.
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Stack-Kontrolle ist zentral, wenn wir:
##
##   - eigene Bootloader bauen
##   - Speicherlecks analysieren
##   - rekursive AblÃ¤ufe in AIMS oder LOGIC nachbilden
##
## RSP/RBP gehÃ¶ren zu den heiligsten Registern â€“ wir behandeln sie
## mit Respekt und PrÃ¤zision.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-04: RIP â€“ Der ProgrammzÃ¤hler
##  â†’ 01-05: Flags â€“ das geheime Statusregister
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-04
#####################################################################
## Lektion 4: RIP â€“ Der ProgrammzÃ¤hler
##
## Das **RIP-Register (Instruction Pointer)** zeigt **immer**
## auf die **Adresse der nÃ¤chsten auszufÃ¼hrenden Instruktion**.
##
## Ohne RIP gÃ¤be es keinen Ablauf. Kein â€Was kommt als NÃ¤chstes?â€œ.
## Kein Sprung, kein Call, kein Return. RIP ist der Taktgeber.
##
## ------------------------
## ğŸ”­ Was macht RIP?
## ------------------------
##
## RIP enthÃ¤lt den Speicherort (Adresse) der nÃ¤chsten Instruktion.
##
## Beispiele:
##   0x4000f3: mov rax, 1
##   0x4000f8: syscall
##
## WÃ¤hrend `mov rax, 1` ausgefÃ¼hrt wird, zeigt RIP auf `0x4000f3`.
## Nach der AusfÃ¼hrung springt RIP automatisch zu `0x4000f8`.
##
## ------------------------
## â†ªï¸ RIP bei SprÃ¼ngen und Aufrufen
## ------------------------
##
## Befehle wie `jmp`, `call`, `ret`, `jne`, `loop` verÃ¤ndern RIP:
##
##   call foo      â†’ RIP = Adresse von `foo`
##   jmp label     â†’ RIP = Adresse von `label`
##   ret           â†’ RIP = Wert vom Stack (RÃ¼cksprungadresse)
##
## Das bedeutet: Jedes Kontrollflusskonstrukt arbeitet mit RIP.
##
## ------------------------
## ğŸ§  RIP & Assembler-Logik
## ------------------------
##
## Moderne CPUs nutzen intern :
##         **Pipelines** und **Speculative Execution**.
##
## RIP steuert diese Logik:
##         â€Welche Anweisung kÃ¶nnte als NÃ¤chstes kommen?â€œ
##
## Deshalb ist RIP oft Ziel von:
##
##   - Buffer Overflow Angriffen
##   - JIT-Manipulationen
##   - Debugging Breakpoints
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## RIP ist wichtig, wenn du:
##
##   - Sprung-Logik in LOGIC-Dateien kontrollierst
##   - eigene Ablaufsteuerung fÃ¼r AIMS entwirfst
##   - BinÃ¤rdaten direkt patchst
##
## Jeder gezielte Sprung oder Call basiert auf RIP.
##
## Du kannst dir RIP wie den Taktstock eines Dirigenten vorstellen:
## Er zeigt, was als NÃ¤chstes kommt â€“ und alles andere folgt.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-05: Flags â€“ das geheime Statusregister
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-05
#####################################################################
## Lektion 5: FLAGS â€“ Das geheime Statusregister
##
## Das **FLAGS-Register** ist kein gewÃ¶hnliches Register.
## Es enthÃ¤lt **einzelne Status-Bits**, die den Zustand des
## letzten Befehls beschreiben â€“ und darÃ¼ber den Programmfluss
## beeinflussen kÃ¶nnen.
##
## ------------------------
## ğŸ¯ Was speichert FLAGS?
## ------------------------
##
## Jedes Bit steht fÃ¼r einen bestimmten Zustand:
##
##   - ZF (Zero Flag)     â†’ Ergebnis war Null?
##   - CF (Carry Flag)    â†’ Ãœbertrag beim Rechnen?
##   - SF (Sign Flag)     â†’ Ergebnis negativ?
##   - OF (Overflow Flag) â†’ RechenÃ¼berlauf passiert?
##
## Beispiel:
##   cmp rax, 5       ; vergleicht rax mit 5
##   je  gleich       ; springt, wenn ZF = 1 (also gleich)
##
## Der CMP-Befehl setzt nur Flags â€“ je/jne/jg/etc. reagieren darauf.
##
## ------------------------
## â±ï¸ FLAGS = Konditionsmaschine
## ------------------------
##
## Flags dienen als Entscheidungsbasis fÃ¼r Kontrollstrukturen:
##
##   - if/else         â†’ Ã¼ber je, jne, jg, jl etc.
##   - Schleifen       â†’ Ã¼ber loop, jcxz, jne
##
## Deshalb werden FLAGS nach **jeder Rechenoperation**
## oder jedem Vergleich **automatisch angepasst**.
##
## ------------------------
## ğŸ” FLAGS lesen & setzen
## ------------------------
##
##   - `lahf`   â†’ lÃ¤dt Flags in AH
##   - `sahf`   â†’ schreibt AH zurÃ¼ck in FLAGS
##   - `pushf`  â†’ speichert FLAGS auf Stack
##   - `popf`   â†’ stellt FLAGS vom Stack wieder her
##
## Du kannst Flags auch gezielt setzen:
##
##   stc     ; Set Carry
##   clc     ; Clear Carry
##   cmc     ; Complement Carry
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## FLAGS sind essenziell bei:
##
##   - Entscheidungs-LOGIC in AIMS
##   - Low-Level-Fehleranalysen (Overflow, Zero Detection)
##   - prÃ¤zisem Debugging im Micro/Nano-Speicherraum
##
## Ohne Flags keine smarte Kontrolle â€“ sie sind das geheime
## Nervensystem jedes Programms.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-06: Segmentregister â€“ FS, GS und ihre verborgene Macht
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-06
#####################################################################
## Lektion 6: Segmentregister â€“ FS, GS und die ihre verborgene Macht
##
## Die Segmentregister stammen aus der frÃ¼hen x86-Zeit, wo
## Speicher noch in â€Segmentenâ€œ organisiert war.
## Heute wirken sie wie Relikte â€“ doch FS und GS sind **mÃ¤chtige
## Werkzeuge** im modernen 64-Bit-System, besonders in der Kernelwelt.
##
## ------------------------
## ğŸ§± Klassische Segmentregister
## ------------------------
##
## In der Theorie gibt es 6 StÃ¼ck:
##
##   - CS (Code Segment)
##   - DS (Data Segment)
##   - SS (Stack Segment)
##   - ES, FS, GS (zusÃ¤tzliche Segmente)
##
## In 64-Bit-Modus: CS, SS etc. werden meist ignoriert â€“ auÃŸer FS/GS!
##
## ------------------------
## ğŸšª FS und GS â€“ TÃ¼ren in verborgene RÃ¤ume
## ------------------------
##
## FS und GS zeigen auf spezielle Speicherbereiche â€“ z.B.:
##
##   - Thread-Local Storage (TLS)
##   - Kernel-Datenstrukturen
##
## Unter Linux zeigt GS z.â€¯B. im Kernelmode oft auf die
## `task_struct` eines Threads â€“ so kÃ¶nnen Prozesse schnell
## auf sich selbst zugreifen.
##
## In Usermode nutzt TLS meist FS:
##
##   mov rax, qword ptr fs:0x30    ; lese Thread-Info
##
## ------------------------
## ğŸ§  Bedeutung fÃ¼r Pylovara / MCS
## ------------------------
##
## FS/GS sind ideal fÃ¼r:
##
##   - isolierte Speicherbereiche je LOGIC/AGENT
##   - Aufbau eines Micro-Scheduling-Systems
##   - Stack-Frame-Erweiterung ohne Zugriffskonflikte
##
## Wer FS/GS kontrolliert, kann Mini-RealitÃ¤ten fÃ¼r jeden
## Prozess definieren â€“ perfekt fÃ¼r das AIMS/MCS-Konzept.
##
## ------------------------
## ğŸ” Zugriff und Manipulation
## ------------------------
##
## Nur mit besonderem Privileg darf man FS/GS Ã¤ndern:
##
##   wrfsbase / wrgsbase (nur ab Haswell+)
##
## FrÃ¼her ging das nur per Systemcall (z.â€¯B. `arch_prctl`)
##
##   syscall: ARCH_SET_FS / ARCH_GET_FS
##
## ------------------------
## âš™ï¸ Beispiele
## ------------------------
##
##   mov rax, gs:0x08     ; lade Daten relativ zu GS
##   mov fs:0x10, rbx     ; schreibe rbx in TLS
##
## Diese relativen Offsets ermÃ¶glichen superschnellen Zugriff
## ohne klassische Pointer-Verwaltung.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-07: RFLAGS, SYSENTER & SYSCALL â€“ System Calls im Detail
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-07
#####################################################################
## Lektion 7: RFLAGS, SYSENTER & SYSCALL â€“ System Calls im Detail
##
## Systemaufrufe sind der heilige Ãœbergang zwischen User-Mode
## und Kernel-Mode. Ohne sie gÃ¤be es keine Dateioperation,
## kein Netzwerk, keinen Zugriff auf GerÃ¤te.
##
## DafÃ¼r zustÃ¤ndig: spezielle Instruktionen wie `syscall`,
## `sysenter` â€“ und das **RFLAGS-Register**, das Kontrollbits trÃ¤gt.
##
## ------------------------
## ğŸ§  RFLAGS â€“ das Kontrollzentrum
## ------------------------
##
## Das RFLAGS-Register enthÃ¤lt Statusbits, u.â€¯a.:
##
##   - CF (Carry Flag)
##   - ZF (Zero Flag)
##   - SF (Sign Flag)
##   - IF (Interrupt Enable Flag)
##
## Beispiel:
##
##   cmp rax, rbx
##   je gleich   ; springt, wenn Zero-Flag gesetzt (ZF=1)
##
## RFLAGS ist kritisch fÃ¼r Entscheidungen, SprÃ¼nge, Interrupts.
##
## ------------------------
## ğŸš€ SYSENTER vs. SYSCALL
## ------------------------
##
## Beides sind Instruktionen fÃ¼r schnelle Systemaufrufe:
##
##   - `sysenter`: Ã¤lter, Intel, braucht vorher MSR-Setup
##   - `syscall` : moderner, AMD64-Standard
##
## Beide sind schneller als klassische Software-Interrupts
## (`int 0x80`), die frÃ¼her genutzt wurden.
##
## Beispiel `syscall`-Nutzung (Linux x86_64 ABI):
##
##   mov rax, 60        ; syscall-nr fÃ¼r exit()
##   xor rdi, rdi       ; rÃ¼ckgabewert = 0
##   syscall            ; Kernel wird aufgerufen
##
## ------------------------
## ğŸ”„ Ablauf eines SYSCALL
## ------------------------
##
## 1.User schreibt Werte in Register (rax = Nummer, rdi, rsi â€¦ = args)
## 2.`syscall` â†’ CPU wechselt in Kernel-Mode
## 3.Kernel liest Register, fÃ¼hrt Operation aus
## 4.RÃ¼ckgabe erfolgt Ã¼ber rax
##
## ------------------------
## ğŸ§© FÃ¼r Pylovara relevant
## ------------------------
##
## Wer `syscall` versteht, kann:
##
##   - Minimalbetriebssysteme wie MCS realisieren
##   - direkten Zugriff auf Kernel-Services ermÃ¶glichen
##   - AIMS-Sensorik in Hardware-nahe Logik Ã¼berfÃ¼hren
##
## RFLAGS wiederum erlaubt:
##
##   - Debug-Traps
##   - bedingte Logik ohne Abfrage-Overhead
##   - feinstufiges Verzweigen in LOGIC-Modulen
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-08: Interrupts & Exceptions â€“ BrÃ¼che in der RealitÃ¤t
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-08
#####################################################################
## Lektion 8: Interrupts & Exceptions â€“ BrÃ¼che in der RealitÃ¤t
##
## Kein System lÃ¤uft perfekt. Manchmal bricht die RealitÃ¤t.
## Genau dafÃ¼r gibt es Interrupts und Exceptions â€“ Reaktionen
## auf plÃ¶tzliche Ereignisse, intern oder extern ausgelÃ¶st.
##
## Diese Mechanismen unterbrechen den normalen Programmfluss
## und Ã¼bergeben die Kontrolle an spezialisierte Handler.
##
## ------------------------
## âš¡ Interrupts (IRQ)
## ------------------------
##
## Interrupts stammen meist von Hardware â€“ z.â€¯B.:
##
##   - TastaturanschlÃ¤ge
##   - Netzwerkpakete
##   - Timer-Signale (z.â€¯B. fÃ¼r Multitasking)
##
## Ablauf:
##
##   1. GerÃ¤t signalisiert Ereignis an CPU
##   2. CPU speichert Zustand, springt zu Interrupt-Handler
##   3. Nach Abarbeitung: RÃ¼ckkehr an vorherige Stelle
##
## Beispiel (x86):
##
##   IRQ1 â†’ Tastatur
##   IRQ0 â†’ PIT (Timer)
##
## ------------------------
## ğŸš¨ Exceptions
## ------------------------
##
## Exceptions entstehen intern â€“ etwa bei:
##
##   - Division durch Null
##   - ungÃ¼ltigem Opcode
##   - Zugriffsverletzungen (Page Fault)
##
## Beispiel:
##
##   div rcx     ; wenn rcx = 0 â†’ #DE (Divide Error)
##
## Auch hier springt die CPU in einen speziellen Exception-Handler.
##
## ------------------------
## ğŸ§  IDT â€“ Interrupt Descriptor Table
## ------------------------
##
## Die IDT ist eine spezielle Tabelle, die jedem Interrupt
## und jeder Exception eine Adresse zuweist â€“ wohin soll
## der Prozessor springen, wenn ein bestimmtes Ereignis eintritt?
##
## Sie ist damit eine Art Notfall-Routing-Tabelle des Systems.
##
## ------------------------
## ğŸ§© Bedeutung fÃ¼r Pylovara
## ------------------------
##
## In einem System wie MCS mit reflexiven AIMS-Agenten sind
## Interrupts der SchlÃ¼ssel fÃ¼r:
##
##   - asynchrone Reaktion auf ZustÃ¤nde
##   - Event-getriebene LOGIC-Strukturen
##   - Hardware-nahe Fehlerbehandlung
##
## Exceptions dagegen:
##
##   - helfen beim Bau stabiler, selbstkorrigierender Module
##   - sind essenziell fÃ¼r Debug-, Analyse- und Schutzmechanismen
##
## Wer Interrupts und Exceptions meistert, kann Systeme bauen,
## die nicht nur reagieren â€“ sondern vorausschauend leben.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-09: Paging, CR3 & Speicherverwaltung
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-09
#####################################################################
## Lektion 9: Paging, CR3 & Speicherverwaltung
##
## Moderne Betriebssysteme arbeiten nicht direkt mit physischem
## Speicher â€“ sie nutzen ein Konzept namens **Paging**.
## Damit entsteht ein virtueller Adressraum fÃ¼r Prozesse.
##
## Dieses System schÃ¼tzt Speicherbereiche, verhindert Kollisionen
## und erlaubt effektives Multitasking.
##
## ------------------------
## ğŸ“¦ Virtuelle Seiten
## ------------------------
##
## Speicher wird in Seiten (Pages) aufgeteilt â€“ meist 4â€¯KB groÃŸ.
##
## Virtuelle Adressen â†’ durch Paging â†’ Physikalische Adressen.
##
## Die CPU nutzt dafÃ¼r mehrere Tabellenebenen:
##
##   - PML4 â†’ PDPT â†’ PD â†’ PT â†’ Page
##
## Das Ganze nennt sich **4-Level Paging** (bei x86_64).
##
## ------------------------
## ğŸ§­ CR3 â€“ Der Pfadwechsler
## ------------------------
##
## Das Register CR3 zeigt auf die **Page Map Level 4
## (PML4)**-Tabelle.
##
## Jeder Prozess bekommt beim Start eine eigene PML4-Struktur.
##
## Wenn der Scheduler Prozesse wechselt, lÃ¤dt er ein neues CR3:
##
##   mov cr3, rax    ; neuer virtueller Speicher-Kontext aktiv
##
## So entstehen isolierte Speicherwelten pro Task.
##
## ------------------------
## ğŸ”’ Schutzmechanismus
## ------------------------
##
## Paging erlaubt gezielten Schutz:
##
##   - User-Space vs. Kernel-Space
##   - Schreibschutz
##   - Nur-AusfÃ¼hrbar-Bereiche (NX-Bit)
##
## Exceptions wie der **Page Fault (#PF)** melden Zugriffe auf
## nicht existierende oder geschÃ¼tzte Seiten.
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Paging ist Grundlage fÃ¼r:
##
##   - Kapselung von AIMS-Modulen
##   - Simulierte Speicherstrukturen in LOGIC
##   - Schutz virtueller Maschineninstanzen
##
## Wer Paging versteht, kann:
##
##   - Speicherkollisionen verhindern
##   - gezielt Speicherbereiche manipulieren
##   - eigene â€Mini-Betriebssystemeâ€œ sicher abbilden
##
## CR3 ist der SchlÃ¼ssel zur SpeicheridentitÃ¤t â€“ wer ihn wechselt,
## Ã¤ndert das Weltbild des Prozessors.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-10: x86_64 Register-Matrix â€“ GesamtÃ¼berblick
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-10
#####################################################################
## Lektion 10: x86_64 Register-Matrix â€“ GesamtÃ¼berblick
##
## Nach den letzten 9 Kapiteln haben wir viele Register kennengelernt.
## Diese Lektion fasst alles in einer strukturierten Ãœbersicht zusammen.
## Die x86_64-Architektur bietet uns **eine Matrix aus 16 Hauptregistern**,
## erweitert durch spezielle Steuer- und Segmentregister.
##
## ------------------------
## ğŸ§  Allgemeine Register
## ------------------------
##
## Diese 16 Register dienen der Datenverarbeitung:
##
##   RAX â€“ Rechen-Accumulator
##   RBX â€“ Daten-Base
##   RCX â€“ ZÃ¤hler (Loop, Shifts)
##   RDX â€“ Daten-Erweiterung (z.B. Division)
##
##   RSI â€“ Source-Index (Strings, memcpy)
##   RDI â€“ Destination-Index
##   RBP â€“ Stack-Basis
##   RSP â€“ Stack-Pointer
##
##   R8  bis R15 â€“ Erweiterte temporÃ¤re Register
##
## Sie alle kÃ¶nnen als 64, 32, 16 oder 8 Bit genutzt werden:
##
##   RAX = 64 Bit â†’ EAX (32) â†’ AX (16) â†’ AL/AH (8)
##
## ------------------------
## ğŸ§­ Steuer- und Kontrollregister
## ------------------------
##
##   RIP   â€“ Instruction Pointer (aktuelle AusfÃ¼hrung)
##   RFLAGS â€“ Statusflags (Zero, Carry, Overflow, etc.)
##   CR0â€“CR4 â€“ Steuerung von Paging, Schutz, usw.
##   CR3   â€“ zeigt auf die PML4 â†’ zentrale Paging-Einheit
##
## ------------------------
## ğŸ§© Segmentregister
## ------------------------
##
## CS, DS, ES, SS â€“ klassische Segmentierung (selten genutzt)
## FS, GS        â€“ moderne Sondersegmente (z.â€¯B. Thread-Local Storage)
##
## ------------------------
## ğŸ›  Spezielle Operationseinheiten
## ------------------------
##
## SYSCALL / SYSENTER â€“ direkter Ãœbergang in Kernel-Modus
## Exceptions / Interrupts â€“ Signale fÃ¼r Fehler oder GerÃ¤te
## MSRs (Model Specific Registers) â€“ Maschinenweite Einstellungen
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Diese Matrix ist wie das **HerzstÃ¼ck des MaschinenkÃ¶rpers**:
##
##   - LOGIC nutzt die semantische Funktion der Register
##   - AIMS kann Registerwerte als Feedback interpretieren
##   - NANO- und MICRO-Module kÃ¶nnen bestimmte Register simulieren
##
## Wer jedes Register in dieser Matrix **versteht, benennt und
## manipuliert**,
##
## kann die Maschine auf Bit-Ebene steuern.
##
## In Pylovara werden wir diese Matrix:
##
##   - visualisieren
##   - simulieren
##   - und als Basis fÃ¼r den BINARCODE-Assembler nutzen
##
#####################################################################
## ğŸ§± NÃ¤chste Kapitelgruppe: 02-XX â€“ Die Befehle (Instruction Set)
##
## Empfohlen: Beginne mit:
##   â†’ 02-01: MOV â€“ Daten verschieben auf Maschinenebene
##
#####################################################################
