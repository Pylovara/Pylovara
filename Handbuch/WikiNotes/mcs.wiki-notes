#############################################################
@wiki-nr: 07 ################################################
#############################################################
@wiki-nr: 07-01 #############################################
#############################################################

MCS-Beispiel 01 – 
„Steam Launcher mit Display-Logik und Fehlerprotokoll“

Ziel :
Ein Programm (hier: **Steam**) wird gestartet.
Dabei wird geprüft, ob ein Display im System (`eDip1`) 
im Vollbildmodus bereitsteht.
Wenn nicht → Fehlerbehandlung und Protokoll.

MCS-Code:
```mcs
¢| steam * exec
  »['exec'|{pfad|/usr/lib/steam/steam}|"$Q"]«
  ¶ »['eDip1'|fullscreen]«
  ¶¶ »['ſ'|{cash|reset}|{log|~/$User/SteamReportPylovara.notes}]«
|¢
```
#############################################################
Erklärung 

`¢| steam * exec`

* `¢|`: Start einer MCS-Sektion (Container).
* `steam`: Logischer Name der Operation.
* `* exec`: Operationstyp → hier ein **ausführbarer Prozess** (exec).

> → Signal: Starte ein logisches Modul namens „steam“, 
            das etwas *ausführen* soll.

`»['exec'|{pfad|/usr/lib/steam/steam}|"$Q"]«`

* `»['exec'|...]«`: Hauptruf – startet den eigentlichen Prozess.
* `{pfad|...}`: Angabe des Speicherorts.
* `"$Q"`: Placeholder für spätere Übergabeparameter oder leere Übergabe.

> → Führt den Steam-Binary aus. `$Q` steht für optionalen, 
    zur Laufzeit übergebbaren Input.

`¶ »['eDip1'|fullscreen]«`

* `¶`: **IF-Bedingung** – hier wird etwas geprüft.
* `»['eDip1'|fullscreen]«`: Teste, ob das Display-Modul `eDip1` 
    im fullscreen-Modus verfügbar ist.

> → Prüft, ob Steam im Vollbildmodus auf dem Display `eDip1` laufen kann.

`¶¶ »['ſ'|{cash|reset}|{log|~/$User/SteamReportPylovara.notes}]«`

* `¶¶`: ELSE-Zweig – wird nur ausgeführt, wenn die vorherige 
*  `¶`  -Bedingung fehlschlägt.
* `['ſ'|...]`: Aufruf des internen Service-Moduls `ſ` (z. B. „Systemflush“ oder „Systemlogik“).
* `{cash|reset}`: Befehl, um einen Caching-Zustand zurückzusetzen.
* `{log|~/$User/...}`: Pfad zur Protokolldatei für die Ausgabe.

> → Falls kein Vollbild möglich: Reset-Caches und logge den Fehler.

Struktur zusammengefasst
| Symbol  | Bedeutung                        |     |                            |
| ------- | -------------------------------- | --- | -------------------------- |
| \`¢     | ...                              | ¢\` | Codeblock (Modulcontainer) |
| `*`     | Art der Operation (exec, map...) |     |                            |
| `»...«` | Ausführung / Prüfung / Logik     |     |                            |
| `¶`     | IF-Zweig                         |     |                            |
| `¶¶`    | ELSE-Zweig                       |     |                            |

Modularer Nutzen
- Erweiterbar: Weitere `¶`- oder `§`-Zweige möglich
- Klarer Fehlerpfad: Saubere Trennung von Logik + Recovery
- Maschinennah: Keine Runtime-Parser-Logik nötig
- Einprägsam: Fast wie ein Mini-Assembler mit Klartext

@wiki-nr: 07-02 #############################################

Vergleich: Klassischer Python-Startpunkt vs. MCS-Mapping

Python-Originalcode:

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-
import re
import sys
from speculum.main import main

if __name__ == "__main__":
    sys.argv[0] = re.sub(r"(-script\.pyw|\.exe)?$", "", sys.argv[0])
    sys.exit(main())
```

*Dieser Code lädt `re`, `sys`, entfernt ggf. Windows/Script-Endungen und startet die `main()`-Routine der `speculum.main`-Datei.*


MCS-Abbildung:

```mcs
¢| re sys * speculum.main
    »['import'|re|sys]«
    »['sys.argv'|0|$@argv0]«
    ¶ »['regex.sub'|"-script\.pyw|\.exe)?$"|""|$@argv0|$@argv0]«
    ¶ »['sys.exit'|main()]«
|¢
```

Erklärung MCS-Logik:
| Zeile              | Bedeutung                 |                                                      |                                  |
| ------------------ | ------------------------- | ---------------------------------------------------- | -------------------------------- |
| \`¢                | re sys \* speculum.main\` | Blockstart, nutzt `re`, `sys`, Ziel: `speculum.main` |                                  |
| \`»\['import'      | re                        | sys]«\`                                              | lädt Module                      |
| \`»\['sys.argv'    | 0                         | \$@argv0]«\`                                         | speichert `sys.argv[0]` temporär |
| \`¶ »\['regex.sub' | "..."]«\`                 | entfernt Endungen wie `-script.pyw`, `.exe`          |                                  |
| \`¶ »\['sys.exit'  | main()]«\`                | startet Main-Funktion & beendet Prozess              |                                  |


Kommentar:
Die MCS-Syntax bietet klare Modularität, lesbare semantische Blöcke 
und eine trennbare Logikarchitektur, die sich später verschachteln, 
ersetzen oder bedingt erweitern lässt – im Gegensatz zur linearen, 
oft "unsichtbaren" Verkettung in Python.
