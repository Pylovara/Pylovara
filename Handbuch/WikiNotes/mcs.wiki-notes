#############################################################
@wiki-nr: 07 ################################################
#############################################################
@wiki-nr: 07-01 #############################################
#############################################################

MCS-Beispiel 01 â€“ 
â€žSteam Launcher mit Display-Logik und Fehlerprotokollâ€œ

Ziel :
Ein Programm (hier: **Steam**) wird gestartet.
Dabei wird geprÃ¼ft, ob ein Display im System (`eDip1`) 
im Vollbildmodus bereitsteht.
Wenn nicht â†’ Fehlerbehandlung und Protokoll.

MCS-Code:
```mcs
Â¢| steam * exec
  Â»['exec'|{pfad|/usr/lib/steam/steam}|"$Q"]Â«
  Â¶ Â»['eDip1'|fullscreen]Â«
  Â¶Â¶ Â»['Å¿'|{cash|reset}|{log|~/$User/SteamReportPylovara.notes}]Â«
|Â¢
```
#############################################################
ErklÃ¤rung 

`Â¢| steam * exec`

* `Â¢|`: Start einer MCS-Sektion (Container).
* `steam`: Logischer Name der Operation.
* `* exec`: Operationstyp â†’ hier ein **ausfÃ¼hrbarer Prozess** (exec).

> â†’ Signal: Starte ein logisches Modul namens â€žsteamâ€œ, 
            das etwas *ausfÃ¼hren* soll.

`Â»['exec'|{pfad|/usr/lib/steam/steam}|"$Q"]Â«`

* `Â»['exec'|...]Â«`: Hauptruf â€“ startet den eigentlichen Prozess.
* `{pfad|...}`: Angabe des Speicherorts.
* `"$Q"`: Placeholder fÃ¼r spÃ¤tere Ãœbergabeparameter oder leere Ãœbergabe.

> â†’ FÃ¼hrt den Steam-Binary aus. `$Q` steht fÃ¼r optionalen, 
    zur Laufzeit Ã¼bergebbaren Input.

`Â¶ Â»['eDip1'|fullscreen]Â«`

* `Â¶`: **IF-Bedingung** â€“ hier wird etwas geprÃ¼ft.
* `Â»['eDip1'|fullscreen]Â«`: Teste, ob das Display-Modul `eDip1` 
    im fullscreen-Modus verfÃ¼gbar ist.

> â†’ PrÃ¼ft, ob Steam im Vollbildmodus auf dem Display `eDip1` laufen kann.

`Â¶Â¶ Â»['Å¿'|{cash|reset}|{log|~/$User/SteamReportPylovara.notes}]Â«`

* `Â¶Â¶`: ELSE-Zweig â€“ wird nur ausgefÃ¼hrt, wenn die vorherige 
*  `Â¶`  -Bedingung fehlschlÃ¤gt.
* `['Å¿'|...]`: Aufruf des internen Service-Moduls `Å¿` (z.â€¯B. â€žSystemflushâ€œ oder â€žSystemlogikâ€œ).
* `{cash|reset}`: Befehl, um einen Caching-Zustand zurÃ¼ckzusetzen.
* `{log|~/$User/...}`: Pfad zur Protokolldatei fÃ¼r die Ausgabe.

> â†’ Falls kein Vollbild mÃ¶glich: Reset-Caches und logge den Fehler.

Struktur zusammengefasst
| Symbol  | Bedeutung                        |     |                            |
| ------- | -------------------------------- | --- | -------------------------- |
| \`Â¢     | ...                              | Â¢\` | Codeblock (Modulcontainer) |
| `*`     | Art der Operation (exec, map...) |     |                            |
| `Â»...Â«` | AusfÃ¼hrung / PrÃ¼fung / Logik     |     |                            |
| `Â¶`     | IF-Zweig                         |     |                            |
| `Â¶Â¶`    | ELSE-Zweig                       |     |                            |

Modularer Nutzen
- Erweiterbar: Weitere `Â¶`- oder `Â§`-Zweige mÃ¶glich
- Klarer Fehlerpfad: Saubere Trennung von Logik + Recovery
- Maschinennah: Keine Runtime-Parser-Logik nÃ¶tig
- EinprÃ¤gsam: Fast wie ein Mini-Assembler mit Klartext

@wiki-nr: 07-02 #############################################

Vergleich: Klassischer Python-Startpunkt vs. MCS-Mapping

Python-Originalcode:

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-
import re
import sys
from speculum.main import main

if __name__ == "__main__":
    sys.argv[0] = re.sub(r"(-script\.pyw|\.exe)?$", "", sys.argv[0])
    sys.exit(main())
```

*Dieser Code lÃ¤dt `re`, `sys`, entfernt ggf. Windows/Script-Endungen und startet die `main()`-Routine der `speculum.main`-Datei.*


MCS-Abbildung:

```mcs
Â¢| re sys * speculum.main
    Â»['import'|re|sys]Â«
    Â»['sys.argv'|0|$@argv0]Â«
    Â¶ Â»['regex.sub'|"-script\.pyw|\.exe)?$"|""|$@argv0|$@argv0]Â«
    Â¶ Â»['sys.exit'|main()]Â«
|Â¢
```

ErklÃ¤rung MCS-Logik:
| Zeile              | Bedeutung                 |                                                      |                                  |
| ------------------ | ------------------------- | ---------------------------------------------------- | -------------------------------- |
| \`Â¢                | re sys \* speculum.main\` | Blockstart, nutzt `re`, `sys`, Ziel: `speculum.main` |                                  |
| \`Â»\['import'      | re                        | sys]Â«\`                                              | lÃ¤dt Module                      |
| \`Â»\['sys.argv'    | 0                         | \$@argv0]Â«\`                                         | speichert `sys.argv[0]` temporÃ¤r |
| \`Â¶ Â»\['regex.sub' | "..."]Â«\`                 | entfernt Endungen wie `-script.pyw`, `.exe`          |                                  |
| \`Â¶ Â»\['sys.exit'  | main()]Â«\`                | startet Main-Funktion & beendet Prozess              |                                  |


Kommentar:
Die MCS-Syntax bietet klare ModularitÃ¤t, lesbare semantische BlÃ¶cke 
und eine trennbare Logikarchitektur, die sich spÃ¤ter verschachteln, 
ersetzen oder bedingt erweitern lÃ¤sst â€“ im Gegensatz zur linearen, 
oft "unsichtbaren" Verkettung in Python.

@wiki-nr: 07-02 #############################################

## ðŸ§¬ MCS als BrÃ¼cken-Kernel â€“ Der universelle Prozesseinstieg

Was ist MCS?
> **MCS** steht fÃ¼r Machine Code Speech â€“ ein universelles, 
semantisches Steuersystem, das als BrÃ¼ckenkern (Bridge Kernel) 
zwischen Mensch und Maschine agiert.
Dabei ersetzt es klassische Shells, Skriptsprachen und sogar 
Low-Level-Kontrollsysteme, indem es alle Anweisungen in 
klar strukturierter, modularer Sprache ausdrÃ¼ckt â€“ 
die sogenannte MCS-Syntax.

---

Wieso â€žBrÃ¼cken-Kernelâ€œ?
* MCS dockt sich unterhalb der Shell an (wie ein Kernel-Sidecar).
* Es kann direkt mit Systemprozessen kommunizieren, egal ob:

  * ðŸ§ Linux (`/bin/sh`, `bash`, `dash`, `zsh`)
  * ðŸŽ macOS (`zsh`, `osascript`, etc.)
  * ðŸªŸ Windows (`powershell`, `cmd`, `wsl`, etc.)

---

### ðŸ§  **Grundidee: Eine Sprache fÃ¼r alle Systeme**

```mcs
Â¢| bash powershell C * native
  Â»['compile'|{codeblock}|{arch|x86_64}]Â«
  Â¶ Â»['run'|{pfad|/home/user/test.sh}]Â«
  Â¶Â¶ Â»['catch'|{log|~/errors.mcsnote}]Â«
|Â¢
```

Diese Blockstruktur kann:
* Ein Shell-Skript ausfÃ¼hren,
* In C kompilieren,
* Einen Fehler abfangen,
* Und das mit einer Syntax â€“ auf jedem OS.

Beispiel: Starte ein universelles Setup

```mcs
Â¢| system * installer
  Â»['scanOS'|{fallback|Linux}]Â«
  Â¶ Â»['if'|{OS|Windows}|Â»['use'|powershell]Â«]Â«
  Â¶ Â»['if'|{OS|Linux}|Â»['use'|bash]Â«]Â«
  Â¶Â¶ Â»['exec'|{pfad|~/Pylovara/start-node.sh}]Â«
|Â¢
```

Ergebnis:
* PrÃ¼ft automatisch das Betriebssystem
* LÃ¤dt den passenden Interpreter
* Startet den Einstiegspunkt in Pylovara

Das macht MCS besonders:
| Merkmal              | Nutzen                                                          |
| -------------------- | --------------------------------------------------------------- |
| ðŸ§© Modular           | Jeder Befehl kann einzeln ersetzt, geprÃ¼ft, rekombiniert werden |
| ðŸ§  Lesbar            | Auch fÃ¼r Einsteiger verstÃ¤ndlich                                |
| ðŸ§¬ System-agnostisch | Mac, Linux, Windows â€“ eine Sprache                              |
| ðŸª¢ Shell-frei        | Kein `#!/bin/bash` oder `.sh` nÃ¶tig â€“ MCS Ã¼bernimmt             |
| ðŸ” Sicher            | Kein Wildwuchs durch unklare Skriptpfade oder AbhÃ¤ngigkeiten    |

Wie funktioniert das technisch?
> MCS lÃ¤uft **innerhalb Pylovara** als Subsystem, aber behandelt Shells wie Treiber.
> Es nutzt Parser und Wrapper, um Systemcalls umzuleiten. Das heiÃŸt:
>
> `run` in MCS â‰  direktes `execve`, sondern eine abstrahierte, kontrollierte Weitergabe
> MCS kann Fehler isoliert loggen oder Weiterleitungen dynamisch umbauen
> Jeder Block ist serialisierbar, prÃ¼fbar, wiederverwendbar


Integration ins System:
> Sobald MCS installiert ist (z.â€¯B. `/usr/lib/pylovara/mcs.bridge`), 
  kannst du deine Shell ignorieren â€“ oder 
  MCS als dein neues Interface verwenden:

```bash
mcs run /etc/init.d/networking restart
```

â€¦ wird automatisch durch den passenden Interpreter geroutet und verarbeitet.


Beispiel : MCS-Startsequenz sieht dann so aus wie:

```mcs
Â¢| init * bootloader
  Â»['check'|{user|root}]Â«
  Â¶ Â»['load'|{module|network.core}]Â«
  Â¶ Â»['ping'|8.8.8.8|timeout=5]Â«
  Â¶Â¶ Â»['log'|{result|~/bootinit.log}]Â«
|Â¢
```




