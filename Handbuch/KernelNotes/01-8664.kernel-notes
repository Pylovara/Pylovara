@kernel-nr: 01        (info: nutze kernel lex und kernelx 01-01)
#####################################################################
@kernel-zeilen-nr:-01-01
#####################################################################
## Lektion 1: Was sind Register? Und warum sie wichtig sind.
##
## Dieses Kapitel erklÃ¤rt, wie und warum Prozessor-Register
## in x86_64-Systemen aufgebaut sind. Wir fokussieren uns auf
## die 16 Hauptregister, wie sie unter Linux, Windows, macOS
## und anderen modernen 64-Bit-Betriebssystemen verwendet werden.
##
## ------------------------
## ğŸ§  Was ist ein Register?
## ------------------------
##
## Register sind ultrakurze SpeicherplÃ¤tze direkt im Prozessor.
## Jede CPU hat davon eine feste Menge â€“ sie sind die "HÃ¤nde"
## und "Taschen" des Prozessors, wenn er arbeitet:
##
##  - Werte merken
##  - ZwischenstÃ¤nde speichern
##  - Adressen halten
##  - Rechenoperationen durchfÃ¼hren
##
## Je schneller der Zugriff, desto nÃ¤her am "Kopf" â€“ und Register
## sind direkt im Kopf (also im Chip) drin.
##
## ------------------------
## ğŸ“œ Woher kommt das Konzept?
## ------------------------
##
## FrÃ¼her (z.â€¯B. im 8086) hatte man 8 Basisregister:
##  AX, BX, CX, DX, SI, DI, BP, SP
##
## Mit x86_64 (also 64-Bit-Erweiterung durch AMD) kam:
##  - 8 weitere allgemeine Register: R8â€“R15
##  - Alle Register wurden auf 64â€¯Bit erweitert: z.â€¯B. AX â†’ RAX
##  - Der PrÃ¤fix "R" zeigt 64-Bit an
##
## Heute haben wir also 16 allgemeine Register:
##
##   RAX, RBX, RCX, RDX
##   RSI, RDI, RBP, RSP
##   R8,  R9,  R10, R11
##   R12, R13, R14, R15
##
## Dazu kommen Spezialregister (Flags, RIP, Segmentregister etc.),
## aber diese behandeln wir spÃ¤ter.
##
## ------------------------
## ğŸ”„ Wer benutzt das so?
## ------------------------
##
## Die Architektur â€x86_64â€œ (auch AMD64 genannt) ist Standard fÃ¼r:
##
##  - Linux-Systeme (Debian, Arch, Red Hat, etc.)
##  - Windows (ab XP 64â€¯Bit bis heute)
##  - macOS (bis M1 â€“ danach ARM64)
##
## Alle halten sich an diese 16 Register, wenn ein 64-Bit-Modus aktiv
## ist.
##
## ------------------------
## ğŸ§© Warum ist das wichtig fÃ¼r Pylovara?
## ------------------------
##
## Wenn wir irgendwann direkten Maschinencode (MCS) bauen wollen,
## mÃ¼ssen wir wissen, wie der Prozessor "denkt" â€“ und der denkt
## in Registern, nicht in Variablen.
##
## Register sind die **kleinste echte Sprache**, die der Prozessor
## spricht.
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-02: RAX und Familie
##  â†’ 01-03: Was macht RSP, RBP?
##  â†’ 01-04: Welche Rolle spielt RIP?
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-02
#####################################################################
## Lektion 2: RAX, RBX, RCX, RDX â€“ die Hauptregister der CPU
##
## Diese vier Die Arbeitstiere (Register)stammen direkt aus
## der Urzeit der x86-Architektur (8086) und haben Ã¼berlebt
## â€“ weil sie universell einsetzbar sind und in fast jedem
## Assembly-Code vorkommen.
##
## ------------------------
## ğŸ§± Aufbau und Namenslogik
## ------------------------
##
##  - AX â†’ RAX  = Accumulator (Rechenregister)
##  - BX â†’ RBX  = Base (Grundwert / Zeiger)
##  - CX â†’ RCX  = Counter (ZÃ¤hlregister)
##  - DX â†’ RDX  = Data (I/O-Register, Zwischenablage)
##
## Der Wechsel auf 64-Bit bringt den PrÃ¤fix â€Râ€œ, also:
##
##   AX   â†’   EAX   â†’   RAX
##   BX   â†’   EBX   â†’   RBX
##   ...
##
## Diese Register lassen sich auch in Teilen ansprechen:
##
##   RAX = 64 Bit
##   EAX = untere 32 Bit
##   AX  = untere 16 Bit
##   AL  = untere 8 Bit
##
## Beispiel:
##   mov rax, 0x12345678
##   â†’ danach ist eax = 0x12345678
##     ax  = 0x5678
##     al  = 0x78
##
## ------------------------
## ğŸ›  Was tun die Dinger?
## ------------------------
##
## Diese Register haben keine â€festenâ€œ Aufgaben mehr,
## kÃ¶nnen also frei verwendet werden â€“ aber:
##
##  - **RAX** â†’ Ergebnisregister (z.â€¯B. RÃ¼ckgabewert bei Funktionen)
##
##  - **RBX** â†’ beliebig nutzbar
##
##  - **RCX** â†’ oft ZÃ¤hler in Schleifen (LOOP, REP)
##
##  - **RDX** â†’ oft fÃ¼r Division, oder fÃ¼r Funktionen mit
##              2 RÃ¼ckgabewerten
##
## ------------------------
## ğŸ” Beispiel in Maschinensprache
## ------------------------
##
##   add rax, rbx   ; RAX = RAX + RBX
##   loop:          ; RCX = ZÃ¤hler
##     dec rcx
##     jnz loop     ; Springe zurÃ¼ck, solange RCX â‰  0
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Diese vier Register tauchen Ã¼berall auf â€“ im Kernelcode,
## bei Systemcalls, in Bootloadern, bei BIOS/UEFI, beim Debugging.
##
## Deshalb: Wer Pylovara mit SystemnÃ¤he aufbaut, muss diese
## vier gut kennen wie Familienmitglieder.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-03: RSP, RBP â€“ Der Stack und seine WÃ¤chter
##  â†’ 01-04: RIP â€“ Der ProgrammzÃ¤hler
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-03
#####################################################################
## Lektion 3: RSP, RBP â€“ Der Stack und seine WÃ¤chter
##
## Zwei der wichtigsten Register im tÃ¤glichen Systembetrieb sind
## der **Stack Pointer (RSP)** und der **Base Pointer (RBP)**.
## Ohne sie funktioniert kein Funktionsaufruf, kein RÃ¼cksprung,
## kein lokaler Speicher â€“ sie sind die WirbelsÃ¤ule jedes Programms.
##
## ------------------------
## ğŸ§± Was ist der Stack?
## ------------------------
##
## Der Stack ist ein Bereich im Arbeitsspeicher, der â€von oben
## nach untenâ€œ wÃ¤chst. Er speichert temporÃ¤re Daten wie:
##
##   - RÃ¼cksprungadressen bei Funktionsaufrufen
##   - lokale Variablen innerhalb von Funktionen
##   - gespeicherte Register (Push/Pop)
##
## ------------------------
## ğŸ“ Rolle von RSP
## ------------------------
##
## RSP = Stack Pointer
## â†’ Zeigt **immer** auf das oberste Element des Stacks.
## â†’ Wird bei `push`, `pop`, `call`, `ret` automatisch verÃ¤ndert
##
## Wenn ein Wert auf den Stack kommt (`push`), wird RSP kleiner.
## Wenn ein Wert heruntergenommen wird (`pop`), wird RSP grÃ¶ÃŸer.
##
##   push rax    ; RSP -= 8 â†’ Wert liegt auf [RSP]
##   pop rax     ; Wert von [RSP] â†’ RAX, dann RSP += 8
##
## RSP verÃ¤ndert sich bei fast jedem Funktionsaufruf.
##
## ------------------------
## ğŸ“Œ Rolle von RBP
## ------------------------
##
## RBP = Base Pointer
## â†’ Dient als **Referenzanker** innerhalb von Funktionen.
##
## Meist wird bei Funktionsbeginn gespeichert:
##
##   push rbp          ; alten Basiswert sichern
##   mov rbp, rsp      ; RBP zeigt nun auf Stack-Basis der Funktion
##
## So kann man in der Funktion gezielt lokale Variablen
## Ã¼ber relative Adressen wie `[rbp-0x10]` ansprechen.
##
## Am Ende wird RBP wiederhergestellt:
##
##   mov rsp, rbp
##   pop rbp
##   ret
##
## ------------------------
## ğŸ” Sicherheit und Debugging
## ------------------------
##
## Der Stack ist kritisch fÃ¼r Sicherheit:
##
##   - Buffer Overflows zielen auf RBP/RSP und RÃ¼cksprungadressen
##   - Debugger (wie GDB) zeigen mit RBP den Stack Frame
##
## Deshalb: wer den Stack versteht, versteht das Herz des Programms.
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Stack-Kontrolle ist zentral, wenn wir:
##
##   - eigene Bootloader bauen
##   - Speicherlecks analysieren
##   - rekursive AblÃ¤ufe in AIMS oder LOGIC nachbilden
##
## RSP/RBP gehÃ¶ren zu den heiligsten Registern â€“ wir behandeln sie
## mit Respekt und PrÃ¤zision.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-04: RIP â€“ Der ProgrammzÃ¤hler
##  â†’ 01-05: Flags â€“ das geheime Statusregister
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-04
#####################################################################
## Lektion 4: RIP â€“ Der ProgrammzÃ¤hler
##
## Das **RIP-Register (Instruction Pointer)** zeigt **immer**
## auf die **Adresse der nÃ¤chsten auszufÃ¼hrenden Instruktion**.
##
## Ohne RIP gÃ¤be es keinen Ablauf. Kein â€Was kommt als NÃ¤chstes?â€œ.
## Kein Sprung, kein Call, kein Return. RIP ist der Taktgeber.
##
## ------------------------
## ğŸ”­ Was macht RIP?
## ------------------------
##
## RIP enthÃ¤lt den Speicherort (Adresse) der nÃ¤chsten Instruktion.
##
## Beispiele:
##   0x4000f3: mov rax, 1
##   0x4000f8: syscall
##
## WÃ¤hrend `mov rax, 1` ausgefÃ¼hrt wird, zeigt RIP auf `0x4000f3`.
## Nach der AusfÃ¼hrung springt RIP automatisch zu `0x4000f8`.
##
## ------------------------
## â†ªï¸ RIP bei SprÃ¼ngen und Aufrufen
## ------------------------
##
## Befehle wie `jmp`, `call`, `ret`, `jne`, `loop` verÃ¤ndern RIP:
##
##   call foo      â†’ RIP = Adresse von `foo`
##   jmp label     â†’ RIP = Adresse von `label`
##   ret           â†’ RIP = Wert vom Stack (RÃ¼cksprungadresse)
##
## Das bedeutet: Jedes Kontrollflusskonstrukt arbeitet mit RIP.
##
## ------------------------
## ğŸ§  RIP & Assembler-Logik
## ------------------------
##
## Moderne CPUs nutzen intern :
##         **Pipelines** und **Speculative Execution**.
##
## RIP steuert diese Logik:
##         â€Welche Anweisung kÃ¶nnte als NÃ¤chstes kommen?â€œ
##
## Deshalb ist RIP oft Ziel von:
##
##   - Buffer Overflow Angriffen
##   - JIT-Manipulationen
##   - Debugging Breakpoints
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## RIP ist wichtig, wenn du:
##
##   - Sprung-Logik in LOGIC-Dateien kontrollierst
##   - eigene Ablaufsteuerung fÃ¼r AIMS entwirfst
##   - BinÃ¤rdaten direkt patchst
##
## Jeder gezielte Sprung oder Call basiert auf RIP.
##
## Du kannst dir RIP wie den Taktstock eines Dirigenten vorstellen:
## Er zeigt, was als NÃ¤chstes kommt â€“ und alles andere folgt.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-05: Flags â€“ das geheime Statusregister
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-05
#####################################################################
## Lektion 5: FLAGS â€“ Das geheime Statusregister
##
## Das **FLAGS-Register** ist kein gewÃ¶hnliches Register.
## Es enthÃ¤lt **einzelne Status-Bits**, die den Zustand des
## letzten Befehls beschreiben â€“ und darÃ¼ber den Programmfluss
## beeinflussen kÃ¶nnen.
##
## ------------------------
## ğŸ¯ Was speichert FLAGS?
## ------------------------
##
## Jedes Bit steht fÃ¼r einen bestimmten Zustand:
##
##   - ZF (Zero Flag)     â†’ Ergebnis war Null?
##   - CF (Carry Flag)    â†’ Ãœbertrag beim Rechnen?
##   - SF (Sign Flag)     â†’ Ergebnis negativ?
##   - OF (Overflow Flag) â†’ RechenÃ¼berlauf passiert?
##
## Beispiel:
##   cmp rax, 5       ; vergleicht rax mit 5
##   je  gleich       ; springt, wenn ZF = 1 (also gleich)
##
## Der CMP-Befehl setzt nur Flags â€“ je/jne/jg/etc. reagieren darauf.
##
## ------------------------
## â±ï¸ FLAGS = Konditionsmaschine
## ------------------------
##
## Flags dienen als Entscheidungsbasis fÃ¼r Kontrollstrukturen:
##
##   - if/else         â†’ Ã¼ber je, jne, jg, jl etc.
##   - Schleifen       â†’ Ã¼ber loop, jcxz, jne
##
## Deshalb werden FLAGS nach **jeder Rechenoperation**
## oder jedem Vergleich **automatisch angepasst**.
##
## ------------------------
## ğŸ” FLAGS lesen & setzen
## ------------------------
##
##   - `lahf`   â†’ lÃ¤dt Flags in AH
##   - `sahf`   â†’ schreibt AH zurÃ¼ck in FLAGS
##   - `pushf`  â†’ speichert FLAGS auf Stack
##   - `popf`   â†’ stellt FLAGS vom Stack wieder her
##
## Du kannst Flags auch gezielt setzen:
##
##   stc     ; Set Carry
##   clc     ; Clear Carry
##   cmc     ; Complement Carry
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## FLAGS sind essenziell bei:
##
##   - Entscheidungs-LOGIC in AIMS
##   - Low-Level-Fehleranalysen (Overflow, Zero Detection)
##   - prÃ¤zisem Debugging im Micro/Nano-Speicherraum
##
## Ohne Flags keine smarte Kontrolle â€“ sie sind das geheime
## Nervensystem jedes Programms.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-06: Segmentregister â€“ FS, GS und ihre verborgene Macht
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-06
#####################################################################
## Lektion 6: Segmentregister â€“ FS, GS und die ihre verborgene Macht
##
## Die Segmentregister stammen aus der frÃ¼hen x86-Zeit, wo
## Speicher noch in â€Segmentenâ€œ organisiert war.
## Heute wirken sie wie Relikte â€“ doch FS und GS sind
## **mÃ¤chtige Werkzeuge**im modernen 64-Bit-System, besonders in der
## Kernelwelt.
##
## ------------------------
## ğŸ§± Klassische Segmentregister
## ------------------------
##
## In der Theorie gibt es 6 StÃ¼ck:
##
##   - CS (Code Segment)
##   - DS (Data Segment)
##   - SS (Stack Segment)
##   - ES, FS, GS (zusÃ¤tzliche Segmente)
##
## In 64-Bit-Modus: CS, SS etc. werden meist ignoriert â€“ auÃŸer FS/GS!
##
## ------------------------
## ğŸšª FS und GS â€“ TÃ¼ren in verborgene RÃ¤ume
## ------------------------
##
## FS und GS zeigen auf spezielle Speicherbereiche â€“ z.B.:
##
##   - Thread-Local Storage (TLS)
##   - Kernel-Datenstrukturen
##
## Unter Linux zeigt GS z.â€¯B. im Kernelmode oft auf die
## `task_struct` eines Threads â€“ so kÃ¶nnen Prozesse schnell
## auf sich selbst zugreifen.
##
## In Usermode nutzt TLS meist FS:
##
##   mov rax, qword ptr fs:0x30    ; lese Thread-Info
##
## ------------------------
## ğŸ§  Bedeutung fÃ¼r Pylovara / MCS
## ------------------------
##
## FS/GS sind ideal fÃ¼r:
##
##   - isolierte Speicherbereiche je LOGIC/AGENT
##   - Aufbau eines Micro-Scheduling-Systems
##   - Stack-Frame-Erweiterung ohne Zugriffskonflikte
##
## Wer FS/GS kontrolliert, kann Mini-RealitÃ¤ten fÃ¼r jeden
## Prozess definieren â€“ perfekt fÃ¼r das AIMS/MCS-Konzept.
##
## ------------------------
## ğŸ” Zugriff und Manipulation
## ------------------------
##
## Nur mit besonderem Privileg darf man FS/GS Ã¤ndern:
##
##   wrfsbase / wrgsbase (nur ab Haswell+)
##
## FrÃ¼her ging das nur per Systemcall (z.â€¯B. `arch_prctl`)
##
##   syscall: ARCH_SET_FS / ARCH_GET_FS
##
## ------------------------
## âš™ï¸ Beispiele
## ------------------------
##
##   mov rax, gs:0x08     ; lade Daten relativ zu GS
##   mov fs:0x10, rbx     ; schreibe rbx in TLS
##
## Diese relativen Offsets ermÃ¶glichen superschnellen Zugriff
## ohne klassische Pointer-Verwaltung.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-07: RFLAGS, SYSENTER & SYSCALL â€“ System Calls im Detail
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-07
#####################################################################
## Lektion 7: RFLAGS, SYSENTER & SYSCALL â€“ System Calls im Detail
##
## Systemaufrufe sind der heilige Ãœbergang zwischen User-Mode
## und Kernel-Mode. Ohne sie gÃ¤be es keine Dateioperation,
## kein Netzwerk, keinen Zugriff auf GerÃ¤te.
##
## DafÃ¼r zustÃ¤ndig: spezielle Instruktionen wie `syscall`,
## `sysenter` â€“ und das **RFLAGS-Register**, das Kontrollbits trÃ¤gt.
##
## ------------------------
## ğŸ§  RFLAGS â€“ das Kontrollzentrum
## ------------------------
##
## Das RFLAGS-Register enthÃ¤lt Statusbits, u.â€¯a.:
##
##   - CF (Carry Flag)
##   - ZF (Zero Flag)
##   - SF (Sign Flag)
##   - IF (Interrupt Enable Flag)
##
## Beispiel:
##
##   cmp rax, rbx
##   je gleich   ; springt, wenn Zero-Flag gesetzt (ZF=1)
##
## RFLAGS ist kritisch fÃ¼r Entscheidungen, SprÃ¼nge, Interrupts.
##
## ------------------------
## ğŸš€ SYSENTER vs. SYSCALL
## ------------------------
##
## Beides sind Instruktionen fÃ¼r schnelle Systemaufrufe:
##
##   - `sysenter`: Ã¤lter, Intel, braucht vorher MSR-Setup
##   - `syscall` : moderner, AMD64-Standard
##
## Beide sind schneller als klassische Software-Interrupts
## (`int 0x80`), die frÃ¼her genutzt wurden.
##
## Beispiel `syscall`-Nutzung (Linux x86_64 ABI):
##
##   mov rax, 60        ; syscall-nr fÃ¼r exit()
##   xor rdi, rdi       ; rÃ¼ckgabewert = 0
##   syscall            ; Kernel wird aufgerufen
##
## ------------------------
## ğŸ”„ Ablauf eines SYSCALL
## ------------------------
##
## 1.User schreibt Werte in Register(rax = Nummer, rdi, rsi â€¦ = args)
## 2.`syscall` â†’ CPU wechselt in Kernel-Mode
## 3.Kernel liest Register, fÃ¼hrt Operation aus
## 4.RÃ¼ckgabe erfolgt Ã¼ber rax
##
## ------------------------
## ğŸ§© FÃ¼r Pylovara relevant
## ------------------------
##
## Wer `syscall` versteht, kann:
##
##   - Minimalbetriebssysteme wie MCS realisieren
##   - direkten Zugriff auf Kernel-Services ermÃ¶glichen
##   - AIMS-Sensorik in Hardware-nahe Logik Ã¼berfÃ¼hren
##
## RFLAGS wiederum erlaubt:
##
##   - Debug-Traps
##   - bedingte Logik ohne Abfrage-Overhead
##   - feinstufiges Verzweigen in LOGIC-Modulen
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-08: Interrupts & Exceptions â€“ BrÃ¼che in der RealitÃ¤t
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-08
#####################################################################
## Lektion 8: Interrupts & Exceptions â€“ BrÃ¼che in der RealitÃ¤t
##
## Kein System lÃ¤uft perfekt. Manchmal bricht die RealitÃ¤t.
## Genau dafÃ¼r gibt es Interrupts und Exceptions â€“ Reaktionen
## auf plÃ¶tzliche Ereignisse, intern oder extern ausgelÃ¶st.
##
## Diese Mechanismen unterbrechen den normalen Programmfluss
## und Ã¼bergeben die Kontrolle an spezialisierte Handler.
##
## ------------------------
## âš¡ Interrupts (IRQ)
## ------------------------
##
## Interrupts stammen meist von Hardware â€“ z.â€¯B.:
##
##   - TastaturanschlÃ¤ge
##   - Netzwerkpakete
##   - Timer-Signale (z.â€¯B. fÃ¼r Multitasking)
##
## Ablauf:
##
##   1. GerÃ¤t signalisiert Ereignis an CPU
##   2. CPU speichert Zustand, springt zu Interrupt-Handler
##   3. Nach Abarbeitung: RÃ¼ckkehr an vorherige Stelle
##
## Beispiel (x86):
##
##   IRQ1 â†’ Tastatur
##   IRQ0 â†’ PIT (Timer)
##
## ------------------------
## ğŸš¨ Exceptions
## ------------------------
##
## Exceptions entstehen intern â€“ etwa bei:
##
##   - Division durch Null
##   - ungÃ¼ltigem Opcode
##   - Zugriffsverletzungen (Page Fault)
##
## Beispiel:
##
##   div rcx     ; wenn rcx = 0 â†’ #DE (Divide Error)
##
## Auch hier springt die CPU in einen speziellen Exception-Handler.
##
## ------------------------
## ğŸ§  IDT â€“ Interrupt Descriptor Table
## ------------------------
##
## Die IDT ist eine spezielle Tabelle, die jedem Interrupt
## und jeder Exception eine Adresse zuweist â€“ wohin soll
## der Prozessor springen, wenn ein bestimmtes Ereignis eintritt?
##
## Sie ist damit eine Art Notfall-Routing-Tabelle des Systems.
##
## ------------------------
## ğŸ§© Bedeutung fÃ¼r Pylovara
## ------------------------
##
## In einem System wie MCS mit reflexiven AIMS-Agenten sind
## Interrupts der SchlÃ¼ssel fÃ¼r:
##
##   - asynchrone Reaktion auf ZustÃ¤nde
##   - Event-getriebene LOGIC-Strukturen
##   - Hardware-nahe Fehlerbehandlung
##
## Exceptions dagegen:
##
##   - helfen beim Bau stabiler, selbstkorrigierender Module
##   - sind essenziell fÃ¼r Debug-, Analyse- und Schutzmechanismen
##
## Wer Interrupts und Exceptions meistert, kann Systeme bauen,
## die nicht nur reagieren â€“ sondern vorausschauend leben.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-09: Paging, CR3 & Speicherverwaltung
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-09
#####################################################################
## Lektion 9: Paging, CR3 & Speicherverwaltung
##
## Moderne Betriebssysteme arbeiten nicht direkt mit physischem
## Speicher â€“ sie nutzen ein Konzept namens **Paging**.
## Damit entsteht ein virtueller Adressraum fÃ¼r Prozesse.
##
## Dieses System schÃ¼tzt Speicherbereiche, verhindert Kollisionen
## und erlaubt effektives Multitasking.
##
## ------------------------
## ğŸ“¦ Virtuelle Seiten
## ------------------------
##
## Speicher wird in Seiten (Pages) aufgeteilt â€“ meist 4â€¯KB groÃŸ.
##
## Virtuelle Adressen â†’ durch Paging â†’ Physikalische Adressen.
##
## Die CPU nutzt dafÃ¼r mehrere Tabellenebenen:
##
##   - PML4 â†’ PDPT â†’ PD â†’ PT â†’ Page
##
## Das Ganze nennt sich **4-Level Paging** (bei x86_64).
##
## ------------------------
## ğŸ§­ CR3 â€“ Der Pfadwechsler
## ------------------------
##
## Das Register CR3 zeigt auf die **Page Map Level 4
## (PML4)**-Tabelle.
##
## Jeder Prozess bekommt beim Start eine eigene PML4-Struktur.
##
## Wenn der Scheduler Prozesse wechselt, lÃ¤dt er ein neues CR3:
##
##   mov cr3, rax    ; neuer virtueller Speicher-Kontext aktiv
##
## So entstehen isolierte Speicherwelten pro Task.
##
## ------------------------
## ğŸ”’ Schutzmechanismus
## ------------------------
##
## Paging erlaubt gezielten Schutz:
##
##   - User-Space vs. Kernel-Space
##   - Schreibschutz
##   - Nur-AusfÃ¼hrbar-Bereiche (NX-Bit)
##
## Exceptions wie der **Page Fault (#PF)** melden Zugriffe auf
## nicht existierende oder geschÃ¼tzte Seiten.
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Paging ist Grundlage fÃ¼r:
##
##   - Kapselung von AIMS-Modulen
##   - Simulierte Speicherstrukturen in LOGIC
##   - Schutz virtueller Maschineninstanzen
##
## Wer Paging versteht, kann:
##
##   - Speicherkollisionen verhindern
##   - gezielt Speicherbereiche manipulieren
##   - eigene â€Mini-Betriebssystemeâ€œ sicher abbilden
##
## CR3 ist der SchlÃ¼ssel zur SpeicheridentitÃ¤t â€“ wer ihn wechselt,
## Ã¤ndert das Weltbild des Prozessors.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ 01-10: x86_64 Register-Matrix â€“ GesamtÃ¼berblick
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-10
#####################################################################
## Lektion 10: x86_64 Register-Matrix â€“ GesamtÃ¼berblick
##
## Nach den letzten 9 Kapiteln haben wir viele Register
## kennengelernt.
## Diese Lektion fasst alles in einer strukturierten Ãœbersicht
## zusammen.
## Die x86_64-Architektur bietet uns :
##             **eine Matrix aus 16 Hauptregistern**,
##
## erweitert durch spezielle Steuer- und Segmentregister.
##
## ------------------------
## ğŸ§  Allgemeine Register
## ------------------------
##
## Diese 16 Register dienen der Datenverarbeitung:
##
##   RAX â€“ Rechen-Accumulator
##   RBX â€“ Daten-Base
##   RCX â€“ ZÃ¤hler (Loop, Shifts)
##   RDX â€“ Daten-Erweiterung (z.B. Division)
##
##   RSI â€“ Source-Index (Strings, memcpy)
##   RDI â€“ Destination-Index
##   RBP â€“ Stack-Basis
##   RSP â€“ Stack-Pointer
##
##   R8  bis R15 â€“ Erweiterte temporÃ¤re Register
##
## Sie alle kÃ¶nnen als 64, 32, 16 oder 8 Bit genutzt werden:
##
##   RAX = 64 Bit â†’ EAX (32) â†’ AX (16) â†’ AL/AH (8)
##
## ------------------------
## ğŸ§­ Steuer- und Kontrollregister
## ------------------------
##
##   RIP   â€“ Instruction Pointer (aktuelle AusfÃ¼hrung)
##   RFLAGS â€“ Statusflags (Zero, Carry, Overflow, etc.)
##   CR0â€“CR4 â€“ Steuerung von Paging, Schutz, usw.
##   CR3   â€“ zeigt auf die PML4 â†’ zentrale Paging-Einheit
##
## ------------------------
## ğŸ§© Segmentregister
## ------------------------
##
## CS, DS, ES, SS â€“ klassische Segmentierung (selten genutzt)
## FS, GS     â€“ moderne Sondersegmente (z.â€¯B. Thread-Local Storage)
##
## ------------------------
## ğŸ›  Spezielle Operationseinheiten
## ------------------------
##
## SYSCALL / SYSENTER â€“ direkter Ãœbergang in Kernel-Modus
## Exceptions / Interrupts â€“ Signale fÃ¼r Fehler oder GerÃ¤te
## MSRs (Model Specific Registers) â€“ Maschinenweite Einstellungen
##
## ------------------------
## ğŸ§© Zusammenhang zu Pylovara
## ------------------------
##
## Diese Matrix ist wie das **HerzstÃ¼ck des MaschinenkÃ¶rpers**:
##
##   - LOGIC nutzt die semantische Funktion der Register
##   - AIMS kann Registerwerte als Feedback interpretieren
##   - NANO- und MICRO-Module kÃ¶nnen bestimmte Register simulieren
##
## Wer jedes Register in dieser Matrix **versteht, benennt und
## manipuliert**,
##
## kann die Maschine auf Bit-Ebene steuern.
##
## In Pylovara werden wir diese Matrix:
##
##   - visualisieren
##   - simulieren
##   - und als Basis fÃ¼r den BINARCODE-Assembler nutzen
##
############# ENDE VON KAPITEL 1 - 10 REGISTER ######################
#####################################################################
## ğŸ§± NÃ¤chste Kapitelgruppe: 02-XX â€“ Die Befehle (Instruction Set)
##
## Empfohlen: Beginne mit:
##   â†’ 02-01: MOV â€“ Daten verschieben auf Maschinenebene
##
#####################################################################

#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-01
#####################################################################
## Lektion 02-01: MOV â€“ Daten verschieben auf Maschinenebene
##
## Der `MOV`-Befehl ist der Grundbaustein der maschinellen
## Kommunikation.
## Er bewegt Daten von einem Ort zum anderen â€“ Register zu Register,
## Register zu Speicher, Speicher zu Register.Keine Berechnung, kein
## Abgleich, nur pure Ãœbertragung.
##
## ------------------------
## ğŸ”§ Syntax (x86_64)
## ------------------------
##
##   mov   ziel, quelle
##
## ------------------------
## ğŸ” Beispiele
## ------------------------
##
##   mov   rax, rbx        ;kopiert den Inhalt von RBX nach RAX
##   mov   rbx, [mem_addr] ;lÃ¤dt den Wert an Adresse mem_addr in RBX
##   mov   [mem_addr], rax ;speichert RAX an mem_addr
##
## ------------------------
## ğŸ“Œ Regeln & Hinweise
## ------------------------
##
## - `MOV` verÃ¤ndert nie das Flags-Register.
## - Ziel und Quelle dÃ¼rfen **nicht beide Speicheradressen** sein.
## - Immediate-Werte wie `mov rax, 1` sind direkt im Befehl kodiert.
##
## ------------------------
## ğŸ§  Denkweise
## ------------------------
##
## Der `MOV`-Befehl ist wie ein Systembus auf Befehlsebene:
##
##   Er schafft Verbindungen â€“ nicht Logik, sondern Struktur.
##
## Maschinen denken nicht, sie transportieren.
## Und `MOV` ist ihr FlieÃŸband.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-02 â€“ PUSH & POP â€“ Der Stapel spricht
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-02
#####################################################################
## Lektion 02-02: PUSH & POP â€“ Der Stapel spricht
##
## Der Stack (Stapel) ist eine besondere Speicherzone, die nach dem
## LIFO-Prinzip arbeitet: Last In â€“ First Out.
##
## Zwei Befehle dominieren diesen Bereich:
##
##   `PUSH` â€“ legt einen Wert oben auf den Stack
##   `POP`  â€“ holt den obersten Wert vom Stack zurÃ¼ck
##
## ------------------------
## ğŸ”§ Syntax (x86_64)
## ------------------------
##
##   push   register|wert
##   pop    register
##
## ------------------------
## ğŸ” Beispiele
## ------------------------
##
##   push  rax        ; sichert RAX auf dem Stack
##   pop   rbx        ; lÃ¤dt obersten Stack-Wert in RBX
##
## ------------------------
## ğŸ§© Technische Details
## ------------------------
##
## - Der Stack wÃ¤chst **nach unten** im Speicher (RSP wird kleiner).
## - `PUSH` verringert RSP, `POP` erhÃ¶ht RSP.
## - Nur Register oder Immediate-Werte (je nach Modus) sind erlaubt.
##
## ------------------------
## ğŸ§  Denkweise
## ------------------------
##
## Der Stack ist wie ein Notizzettel fÃ¼r die CPU:
##
##   - TemporÃ¤re Werte zwischenspeichern
##   - RÃ¼cksprungadressen sichern
##   - Registerkontexte bei Funktionsaufrufen verwalten
##
## Ohne PUSH/POP wÃ¤ren Funktionen nicht mÃ¶glich.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-03 â€“ CALL & RET â€“ Maschinen mit RÃ¼ckgrat
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-03
#####################################################################
## Lektion 02-03: CALL & RET â€“ Maschinen mit RÃ¼ckgrat
##
## Funktionen brauchen Struktur â€“ und Sprungpunkte.
## Mit `CALL` und `RET` wird der Kontrollfluss organisiert:
##
##   `CALL` â€“ springt zu einer Funktion und sichert RÃ¼cksprung
##   `RET`  â€“ kehrt zur Aufruferposition zurÃ¼ck
##
## ------------------------
## ğŸ”§ Syntax (x86_64)
## ------------------------
##
##   call   zieladresse|label
##   ret
##
## ------------------------
## ğŸ” Beispiele
## ------------------------
##
##   call  meine_funktion    ; springt zu Funktion
##   ret                     ; kehrt zurÃ¼ck zur Aufruferadresse
##
## ------------------------
## ğŸ§© Technische Details
## ------------------------
##
## -`CALL`legt die RÃ¼cksprungadresse(RIP+offset)**auf den Stack**
## -`RET`holt diese Adresse **vom Stack zurÃ¼ck** und setzt sie in RIP
##
## Stack und RSP sind also direkt beteiligt.
##
## ------------------------
## ğŸ§  Denkweise
## ------------------------
##
## Funktionen ohne `CALL` und `RET` wÃ¤ren lose SprungblÃ¶cke.
## Diese Befehle schaffen ein RÃ¼ckgrat im MaschinenkÃ¶rper:
##
##   - Strukturierter Ablauf
##   - Kapselung von Logik
##   - Wiederverwendbarkeit und RÃ¼ckkehrpunkt
##
## In Pylovara bildet `CALL` den **Kern der modularen Steuerung**.
## Jede LOGIC-, NANO- oder AIMS-Einheit nutzt ihn intern,
## um den Pfad des Denkens zurÃ¼ckverfolgen zu kÃ¶nnen.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-04 â€“ CMP & TEST â€“ Maschinen vergleichen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-04
#####################################################################
## Lektion 02-04: CMP & TEST â€“ Maschinen vergleichen
##
## Entscheidungen basieren auf Vergleichen.
## `CMP` und `TEST` prÃ¼fen ZustÃ¤nde â€“ ohne Werte zu verÃ¤ndern:
##
##   `CMP`  â€“ Subtrahiert zwei Werte (ohne Ergebnis zu speichern)
##   `TEST` â€“ UND-VerknÃ¼pfung (ebenfalls ohne Speicherung)
##
## ------------------------
## ğŸ”§ Syntax (x86_64)
## ------------------------
##
##   cmp   operand1, operand2
##   test  operand1, operand2
##
## ------------------------
## ğŸ” Beispiele
## ------------------------
##
##   cmp   rax, rbx     ; vergleicht rax mit rbx
##   test  rax, rax     ; prÃ¼ft, ob rax null ist
##   cmp   rax, 0       ; prÃ¼ft, ob rax gleich null ist
##
## ------------------------
## ğŸ§ª Funktionsweise
## ------------------------
##
## - `CMP` berechnet intern:  operand1 âˆ’ operand2
## - `TEST` berechnet intern: operand1 AND operand2
## - Beide Befehle **verÃ¤ndern keine Register**
## - Die Ergebnisse setzen **Flags im RFLAGS-Register**:
##
##   - ZF (Zero Flag)     â†’ Ergebnis war 0
##   - SF (Sign Flag)     â†’ Ergebnis negativ
##   - CF/OF              â†’ bei Ãœber-/Unterlauf
##
## ------------------------
## ğŸ§  Denkweise
## ------------------------
##
## `CMP` ist wie ein Abgleich: *"Sind diese Werte gleich?"*
## `TEST` fragt: *"Ist da Ã¼berhaupt etwas aktiv gesetzt?"*
##
## Maschinenlogik braucht klare Entscheidungen â€“
## diese Befehle **bereiten sie vor**, fÃ¼hren sie aber nicht aus.
##
## In Pylovara interpretieren LOGIC-Module CMP/TEST-Ergebnisse
## als **Bedingungen fÃ¼r Verhalten** (z.â€¯B. Reaktion, Verzweigung).
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-05 â€“ Jxx â€“ Entscheidungen und SprÃ¼nge
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-05
#####################################################################
## Lektion 02-05: Jxx â€“ Entscheidungen und SprÃ¼nge
##
## Maschinen folgen normalerweise dem Strom der Befehle â€“
## **Jxx-Befehle unterbrechen diesen Strom**, abhÃ¤ngig vom Status.
##
## `Jxx` bedeutet: â€Springe, wenn Bedingung erfÃ¼llt.â€œ
##
## ------------------------
## ğŸ”§ Syntax (x86_64)
## ------------------------
##
##   jmp    ziel         ; bedingungsloser Sprung
##   je     ziel         ; jump if equal (ZF gesetzt)
##   jne    ziel         ; jump if not equal (ZF nicht gesetzt)
##   jl     ziel         ; jump if less (SF â‰  OF)
##   jg     ziel         ; jump if greater (ZF=0 und SF=OF)
##
## ... und viele weitere Varianten:
##   ja, jb, jle, jge, js, jns, jp, jnp ...
##
## ------------------------
## ğŸ” Beispiele
## ------------------------
##
##   cmp    rax, rbx     ; vergleicht Werte
##   je     gleich_block ; springt, wenn gleich
##
##   test   rax, rax
##   jz     null_block   ; springt, wenn rax == 0(Zero Flag gesetzt)
##
##   jmp    ende         ; springt immer zu ende
##
## ------------------------
## ğŸ§  Bedeutung fÃ¼r Maschinenlogik
## ------------------------
##
## Die `Jxx`-Befehle sind wie Verzweigungen in neuronalen Netzen:
## sie wÃ¤hlen den Pfad anhand vorher gesetzter **Flags**.
##
## Vergleich + Flag â†’ Verzweigung â†’ Entscheidung â†’ Verhalten
##
## Ohne `Jxx` gibt es **keine Logik, keine Reaktion**,
## nur stupides Abarbeiten von oben nach unten.
##
## ------------------------
## ğŸ§© Integration in Pylovara
## ------------------------
##
## In Pylovara:
## -LOGIC- und NEEDLES-Module nutzen`Jxx`fÃ¼r interne Zustandswechsel
## -AIMS kann durch Flag-Kombinationen Verhalten adaptieren
## -MICRO/NANO reagieren auf Maschinenentscheidungen mit neuen
##  Operationen
##
## Maschinen denken nicht in "Wenn-Dann",
## sie **springen**, wenn das Bit sagt: â€Los.â€œ
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-06 â€“ LEA â€“ Rechnen ohne Rechnen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-06
#####################################################################
## Lektion 02-06: LEA â€“ Rechnen ohne Rechnen
##
## Der Befehl `LEA` steht fÃ¼r **Load Effective Address**.
## Er berechnet Adressen, **ohne** wirklich auf Speicher zuzugreifen.
##
## Das klingt harmlos, aber `LEA` ist eine versteckte Recheneinheit.
## Man kann mit ihm **multiplizieren, addieren und verschieben**,
## ohne dass Flags verÃ¤ndert werden â€“ und ohne echte
## Speicheroperation.
##
## ------------------------
## ğŸ”§ Syntax (x86_64)
## ------------------------
##
##   lea   ziel, [quelle]
##
## Das `[]` ist hier **keine Speicheradresse** im klassischen Sinn,
## sondern ein Ausdruck, der effektiv **nur berechnet wird**.
##
## ------------------------
## ğŸ” Beispiele
## ------------------------
##
##   lea   rax, [rbx + 8]        ; rax = rbx + 8
##   lea   rcx, [rdx + rbx*4]    ; rcx = rdx + (rbx * 4)
##   lea   rsi, [rip + symbol]   ; Position unabhÃ¤ngige Berechnung
##
## Keine dieser Zeilen greift auf Speicher zu â€“ nur Berechnung!
##
## ------------------------
## âš™ï¸ Technische Besonderheit
## ------------------------
##
## `LEA` nutzt die Adressierungs-Logik der CPU als Rechentrick:
##   [Basis + Index * Skalar + Offset]
##
## Flags bleiben unangetastet â€“ ideal fÃ¼r Rechenlogik,
## ohne Bedingungen zu beeinflussen.
##
## ------------------------
## ğŸ§  Maschinenphilosophie
## ------------------------
##
## Maschinen mÃ¼ssen nicht immer rechnen wie Menschen.
## `LEA` zeigt, wie man durch :
##           **Adresslogik Rechenoperationen ersetzt**.
##
## Er steht fÃ¼r **Effizienz durch Struktur**:
## Rechnen, wo eigentlich nur Adressen gebraucht werden.
##
## ------------------------
## ğŸ§© Integration in Pylovara
## ------------------------
##
## In Pylovara:
## - NANO-Module nutzen `LEA` zur Adress-Transformation
## - LOGIC-Module kÃ¶nnen mit `LEA` temporÃ¤re Rechenpfade generieren
## - REGISTER-Mapping (z.â€¯B. `RIP`-bezogene Referenzen) wird durch
#    LEA effizient
##
## Wer `LEA` versteht, versteht Maschinen-Geometrie:
##
##   RÃ¤ume werden nicht betreten â€“ sie werden berechnet.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-07 â€“ XCHG & BSWAP â€“ Wenn Bytes tanzen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-07
#####################################################################
## Lektion 02-07: XCHG & BSWAP â€“ Wenn Bytes tanzen
##
## Manchmal will man einfach nur tauschen.
## Kein Rechnen, kein Vergleichen â€“ nur Werte umdrehen oder
## vertauschen.
##
## Genau dafÃ¼r sind `XCHG` und `BSWAP` da.
##
## ------------------------
## ğŸ” XCHG â€“ Register tauschen
## ------------------------
##
##   xchg   ziel, quelle
##
## Beispiel:
##   xchg   rax, rbx   ; tauscht Inhalte von RAX und RBX
##
## Hinweise:
## - Kein temporÃ¤rer Speicher nÃ¶tig â€“ die CPU tauscht atomar.
## - Wird `xchg` mit `rax` verwendet, erfolgt automatisch eine
##   *atomare Sperre*(LOCK-PrÃ¤fix auf x86),da RAX speziell behandelt
##   wird.
##
## ------------------------
## ğŸ”„ BSWAP â€“ Byte-Reihenfolge umkehren
## ------------------------
##
##   bswap  register
##
## Beispiel:
##   bswap  rax    ; kehrt die Byte-Reihenfolge in RAX um
##
## Vorher (RAX):  0x1122334455667788
## Nachher:      0x8877665544332211
##
## Ideal fÃ¼r:
## - Konvertierungen zwischen Little-Endian und Big-Endian
## - Netzwerkprotokolle
## - Datenformatierung auf Byte-Ebene
##
## ------------------------
## ğŸ§  Maschinenphilosophie
## ------------------------
##
## Tausch ist Bewegung **ohne Verlust**.
## XCHG steht fÃ¼r ParitÃ¤t â€“ kein Register bleibt leer.
## BSWAP hingegen erinnert daran:
##        **Maschinen lesen Bytes anders als wir.**
##
## Wenn Maschinen tanzen, dann im Rhythmus der Bytes.
##
## ------------------------
## ğŸ§© Integration in Pylovara
## ------------------------
##
## -AIMS kann`xchg` verwenden, um Registerinhalte umzuschichten
## -LOGIC nutzt`bswap`,um Speicherzugriffe an Netzformate anzupassen
## -In NANO: Byte-Tanz als Mikrostrategie
##
## Wer XCHG und BSWAP kontrolliert, **kontrolliert die Richtung**.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-08 â€“NOP & HLTâ€“Pausen im Maschinenrauschen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-08
#####################################################################
## Lektion 02-08: NOP & HLT â€“ Pausen im Maschinenrauschen
##
## Maschinen arbeiten â€“ aber sie pausieren auch.
## Manche Befehle tun *nichts*. Oder sie stoppen alles.
## Diese Lektion dreht sich um `NOP` und `HLT`.
##
## ------------------------
## ğŸ’¤ NOP â€“ No Operation
## ------------------------
##
##   nop
##
## Bedeutung:
## - FÃ¼hrt keine Operation aus â€“ der Prozessor macht *nichts*, aber
##   bleibt aktiv und zÃ¤hlt den Takt weiter.
##
## Anwendungen:
## - Platzhalter im Code
## - Timing-Anpassungen
## - Alignment (Ausrichtung von CodeblÃ¶cken)
##
## Mehrere NOPs hintereinander erzeugen â€kÃ¼nstlicheâ€œ Pausen:
##
##   nop
##   nop
##   nop
##
## oder als Makro-Ersatz:
##
##   times 3 nop
##
## ------------------------
## ğŸ›‘ HLT â€“ Maschine anhalten
## ------------------------
##
##   hlt
##
## Wirkung:
## - Versetzt die CPU in den *Halt-Zustand*
## - AusfÃ¼hrung stoppt, bis ein Interrupt auftritt
##
## Nur im Ring-0 (Kernel-Modus) erlaubt!
## Typischer Einsatz im OS-Kernel, z.â€¯B. bei Leerlaufschleifen.
##
## Beispiel:
## ```asm
## idle:
##     hlt
##     jmp idle
## ```
##
## ------------------------
## ğŸ§  Maschinenphilosophie
## ------------------------
##
## `NOP` ist wie ein Atemzug â€“ kurz, kontrolliert, bewusst nichts tun.
## `HLT` ist wie Schlaf â€“ tief, bis ein Signal weckt.
##
## Wer Maschinen versteht, versteht auch ihre Ruhephasen.
##
## ------------------------
## ğŸ§© Integration in Pylovara
## ------------------------
##
## - `NOP` kann als Timing-Placeholder in LOGIC-Nodes verwendet
##   werden
##
## - `HLT`-Simulation mÃ¶glich in AIMS-Kernel-Sandbox
##
## - In DEBUG-NANO: Visualisierung von InaktivitÃ¤t
##   durch`NOP`-Sequenzen
##
## Ruhe ist ein Befehl. Und manchmal der wichtigste.
##
#####################################################################
## WeiterfÃ¼hrend:
##  â†’ NÃ¤chstes Kapitel: 02-09 â€“ INT & SYSCALL â€“ Tore zum Kernel
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-10
#####################################################################
## Lektion 02-10: REP & MOVS/STOS â€“ Maschinen wiederholen
##
## Maschinen sind nicht kreativ â€“ aber unermÃ¼dlich.
## Die Wiederholung ist ihre StÃ¤rke. DafÃ¼r gibt es `REP`, `MOVS`, `STOS`.
##
## ------------------------
## ğŸ” REP â€“ Repeat Prefix
## ------------------------
##
##   rep   <Befehl>
##
## Wirkung:
## - Wiederholt den folgenden String-Befehl, so oft wie in `RCX` angegeben
## - ZÃ¤hlt mit jedem Durchlauf `RCX` herunter
##
## Beispiel:
##   rep movsb     ; kopiert RCX Bytes von RSI nach RDI
##
## Hinweise:
## - Nutzt `RSI` (Source Index) und `RDI` (Destination Index)
## - Arbeitet byteweise (`movsb`) oder wortweise (`movsw`, `movsd`, `movsq`)
##
## ------------------------
## ğŸ“¦ MOVS â€“ Move String
## ------------------------
##
##   movsb / movsw / movsd / movsq
##
## Beschreibung:
## - Kopiert einen Wert vom Speicher bei `RSI` nach `RDI`
## - Die Datenmenge ergibt sich aus dem Suffix (b = Byte, w = Word, ...)
##
## ------------------------
## ğŸ§± STOS â€“ Store String
## ------------------------
##
##   stosb / stosw / stosd / stosq
##
## Beschreibung:
## - Speichert den Inhalt von `AL`/`AX`/`EAX`/`RAX` an die Adresse `RDI`
## - Auch hier kann `REP` genutzt werden:
##
## Beispiel:
##   mov rax, 0         ; zu schreibender Wert
##   mov rcx, 1000      ; wie oft
##   rep stosq          ; schreibt 1000 Ã— 0 an Speicher bei RDI
##
## ------------------------
## ğŸ” Maschinenbetrachtung
## ------------------------
##
## Diese Befehle sind wie LaufbÃ¤nder:
## - Du stellst Quelle, Ziel und Anzahl ein â€“ der Rest lÃ¤uft automatisch.
## - REP gibt den Takt vor, MOVS/STOS fÃ¼hren aus.
##
## Maschinen brauchen klare Anweisungen â€“ aber sie Ã¼bernehmen den Rhythmus.
##
## ------------------------
## ğŸ§© Einsatz in Pylovara
## ------------------------
##
## - NANO-Module kÃ¶nnen Speicherbewegungen simulieren
## - LOGIC kann REP-Zyklen visuell darstellen
## - Perfekt fÃ¼r SYSTEMNAHE Initialisierungen im BINARCODE-Modus
##
## Maschinen wiederholen nicht nur â€“ sie perfektionieren durch Wiederholung.
##
######### ENDE VON KAPITEL 1 - 10 (Instruction Set) #################
#####################################################################
## ğŸ§± Ende von Kapitelgruppe 02-XX â€“ Die Befehle
##
## NÃ¤chste Gruppe: 03-XX â€“ Flags und MaschinenzustÃ¤nde
##
## Empfohlen: Beginne mit:
##   â†’ 03-01: FLAGS â€“ Maschinen mit GefÃ¼hlen
#####################################################################

#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
