@kernel-nr: 01        (info: nutze kernel lex und kernelx 01-01)
#####################################################################
@kernel-zeilen-nr:-01-01
#####################################################################
## Lektion 1: Was sind Register? Und warum sie wichtig sind.
##
## Dieses Kapitel erklärt, wie und warum Prozessor-Register
## in x86_64-Systemen aufgebaut sind. Wir fokussieren uns auf
## die 16 Hauptregister, wie sie unter Linux, Windows, macOS
## und anderen modernen 64-Bit-Betriebssystemen verwendet werden.
##
## ------------------------
## 🧠 Was ist ein Register?
## ------------------------
##
## Register sind ultrakurze Speicherplätze direkt im Prozessor.
## Jede CPU hat davon eine feste Menge – sie sind die "Hände"
## und "Taschen" des Prozessors, wenn er arbeitet:
##
##  - Werte merken
##  - Zwischenstände speichern
##  - Adressen halten
##  - Rechenoperationen durchführen
##
## Je schneller der Zugriff, desto näher am "Kopf" – und Register
## sind direkt im Kopf (also im Chip) drin.
##
## ------------------------
## 📜 Woher kommt das Konzept?
## ------------------------
##
## Früher (z. B. im 8086) hatte man 8 Basisregister:
##  AX, BX, CX, DX, SI, DI, BP, SP
##
## Mit x86_64 (also 64-Bit-Erweiterung durch AMD) kam:
##  - 8 weitere allgemeine Register: R8–R15
##  - Alle Register wurden auf 64 Bit erweitert: z. B. AX → RAX
##  - Der Präfix "R" zeigt 64-Bit an
##
## Heute haben wir also 16 allgemeine Register:
##
##   RAX, RBX, RCX, RDX
##   RSI, RDI, RBP, RSP
##   R8,  R9,  R10, R11
##   R12, R13, R14, R15
##
## Dazu kommen Spezialregister (Flags, RIP, Segmentregister etc.),
## aber diese behandeln wir später.
##
## ------------------------
## 🔄 Wer benutzt das so?
## ------------------------
##
## Die Architektur „x86_64“ (auch AMD64 genannt) ist Standard für:
##
##  - Linux-Systeme (Debian, Arch, Red Hat, etc.)
##  - Windows (ab XP 64 Bit bis heute)
##  - macOS (bis M1 – danach ARM64)
##
## Alle halten sich an diese 16 Register, wenn ein 64-Bit-Modus aktiv
## ist.
##
## ------------------------
## 🧩 Warum ist das wichtig für Pylovara?
## ------------------------
##
## Wenn wir irgendwann direkten Maschinencode (MCS) bauen wollen,
## müssen wir wissen, wie der Prozessor "denkt" – und der denkt
## in Registern, nicht in Variablen.
##
## Register sind die **kleinste echte Sprache**, die der Prozessor
## spricht.
#####################################################################
## Weiterführend:
##  → 01-02: RAX und Familie
##  → 01-03: Was macht RSP, RBP?
##  → 01-04: Welche Rolle spielt RIP?
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-02
#####################################################################
## Lektion 2: RAX, RBX, RCX, RDX – die Hauptregister der CPU
##
## Diese vier Die Arbeitstiere (Register)stammen direkt aus
## der Urzeit der x86-Architektur (8086) und haben überlebt
## – weil sie universell einsetzbar sind und in fast jedem
## Assembly-Code vorkommen.
##
## ------------------------
## 🧱 Aufbau und Namenslogik
## ------------------------
##
##  - AX → RAX  = Accumulator (Rechenregister)
##  - BX → RBX  = Base (Grundwert / Zeiger)
##  - CX → RCX  = Counter (Zählregister)
##  - DX → RDX  = Data (I/O-Register, Zwischenablage)
##
## Der Wechsel auf 64-Bit bringt den Präfix „R“, also:
##
##   AX   →   EAX   →   RAX
##   BX   →   EBX   →   RBX
##   ...
##
## Diese Register lassen sich auch in Teilen ansprechen:
##
##   RAX = 64 Bit
##   EAX = untere 32 Bit
##   AX  = untere 16 Bit
##   AL  = untere 8 Bit
##
## Beispiel:
##   mov rax, 0x12345678
##   → danach ist eax = 0x12345678
##     ax  = 0x5678
##     al  = 0x78
##
## ------------------------
## 🛠 Was tun die Dinger?
## ------------------------
##
## Diese Register haben keine „festen“ Aufgaben mehr,
## können also frei verwendet werden – aber:
##
##  - **RAX** → Ergebnisregister (z. B. Rückgabewert bei Funktionen)
##
##  - **RBX** → beliebig nutzbar
##
##  - **RCX** → oft Zähler in Schleifen (LOOP, REP)
##
##  - **RDX** → oft für Division, oder für Funktionen mit
##              2 Rückgabewerten
##
## ------------------------
## 🔁 Beispiel in Maschinensprache
## ------------------------
##
##   add rax, rbx   ; RAX = RAX + RBX
##   loop:          ; RCX = Zähler
##     dec rcx
##     jnz loop     ; Springe zurück, solange RCX ≠ 0
##
## ------------------------
## 🧩 Zusammenhang zu Pylovara
## ------------------------
##
## Diese vier Register tauchen überall auf – im Kernelcode,
## bei Systemcalls, in Bootloadern, bei BIOS/UEFI, beim Debugging.
##
## Deshalb: Wer Pylovara mit Systemnähe aufbaut, muss diese
## vier gut kennen wie Familienmitglieder.
##
#####################################################################
## Weiterführend:
##  → 01-03: RSP, RBP – Der Stack und seine Wächter
##  → 01-04: RIP – Der Programmzähler
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-03
#####################################################################
## Lektion 3: RSP, RBP – Der Stack und seine Wächter
##
## Zwei der wichtigsten Register im täglichen Systembetrieb sind
## der **Stack Pointer (RSP)** und der **Base Pointer (RBP)**.
## Ohne sie funktioniert kein Funktionsaufruf, kein Rücksprung,
## kein lokaler Speicher – sie sind die Wirbelsäule jedes Programms.
##
## ------------------------
## 🧱 Was ist der Stack?
## ------------------------
##
## Der Stack ist ein Bereich im Arbeitsspeicher, der „von oben
## nach unten“ wächst. Er speichert temporäre Daten wie:
##
##   - Rücksprungadressen bei Funktionsaufrufen
##   - lokale Variablen innerhalb von Funktionen
##   - gespeicherte Register (Push/Pop)
##
## ------------------------
## 📍 Rolle von RSP
## ------------------------
##
## RSP = Stack Pointer
## → Zeigt **immer** auf das oberste Element des Stacks.
## → Wird bei `push`, `pop`, `call`, `ret` automatisch verändert
##
## Wenn ein Wert auf den Stack kommt (`push`), wird RSP kleiner.
## Wenn ein Wert heruntergenommen wird (`pop`), wird RSP größer.
##
##   push rax    ; RSP -= 8 → Wert liegt auf [RSP]
##   pop rax     ; Wert von [RSP] → RAX, dann RSP += 8
##
## RSP verändert sich bei fast jedem Funktionsaufruf.
##
## ------------------------
## 📌 Rolle von RBP
## ------------------------
##
## RBP = Base Pointer
## → Dient als **Referenzanker** innerhalb von Funktionen.
##
## Meist wird bei Funktionsbeginn gespeichert:
##
##   push rbp          ; alten Basiswert sichern
##   mov rbp, rsp      ; RBP zeigt nun auf Stack-Basis der Funktion
##
## So kann man in der Funktion gezielt lokale Variablen
## über relative Adressen wie `[rbp-0x10]` ansprechen.
##
## Am Ende wird RBP wiederhergestellt:
##
##   mov rsp, rbp
##   pop rbp
##   ret
##
## ------------------------
## 🔐 Sicherheit und Debugging
## ------------------------
##
## Der Stack ist kritisch für Sicherheit:
##
##   - Buffer Overflows zielen auf RBP/RSP und Rücksprungadressen
##   - Debugger (wie GDB) zeigen mit RBP den Stack Frame
##
## Deshalb: wer den Stack versteht, versteht das Herz des Programms.
##
## ------------------------
## 🧩 Zusammenhang zu Pylovara
## ------------------------
##
## Stack-Kontrolle ist zentral, wenn wir:
##
##   - eigene Bootloader bauen
##   - Speicherlecks analysieren
##   - rekursive Abläufe in AIMS oder LOGIC nachbilden
##
## RSP/RBP gehören zu den heiligsten Registern – wir behandeln sie
## mit Respekt und Präzision.
##
#####################################################################
## Weiterführend:
##  → 01-04: RIP – Der Programmzähler
##  → 01-05: Flags – das geheime Statusregister
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-04
#####################################################################
## Lektion 4: RIP – Der Programmzähler
##
## Das **RIP-Register (Instruction Pointer)** zeigt **immer**
## auf die **Adresse der nächsten auszuführenden Instruktion**.
##
## Ohne RIP gäbe es keinen Ablauf. Kein „Was kommt als Nächstes?“.
## Kein Sprung, kein Call, kein Return. RIP ist der Taktgeber.
##
## ------------------------
## 🔭 Was macht RIP?
## ------------------------
##
## RIP enthält den Speicherort (Adresse) der nächsten Instruktion.
##
## Beispiele:
##   0x4000f3: mov rax, 1
##   0x4000f8: syscall
##
## Während `mov rax, 1` ausgeführt wird, zeigt RIP auf `0x4000f3`.
## Nach der Ausführung springt RIP automatisch zu `0x4000f8`.
##
## ------------------------
## ↪️ RIP bei Sprüngen und Aufrufen
## ------------------------
##
## Befehle wie `jmp`, `call`, `ret`, `jne`, `loop` verändern RIP:
##
##   call foo      → RIP = Adresse von `foo`
##   jmp label     → RIP = Adresse von `label`
##   ret           → RIP = Wert vom Stack (Rücksprungadresse)
##
## Das bedeutet: Jedes Kontrollflusskonstrukt arbeitet mit RIP.
##
## ------------------------
## 🧠 RIP & Assembler-Logik
## ------------------------
##
## Moderne CPUs nutzen intern :
##         **Pipelines** und **Speculative Execution**.
##
## RIP steuert diese Logik:
##         „Welche Anweisung könnte als Nächstes kommen?“
##
## Deshalb ist RIP oft Ziel von:
##
##   - Buffer Overflow Angriffen
##   - JIT-Manipulationen
##   - Debugging Breakpoints
##
## ------------------------
## 🧩 Zusammenhang zu Pylovara
## ------------------------
##
## RIP ist wichtig, wenn du:
##
##   - Sprung-Logik in LOGIC-Dateien kontrollierst
##   - eigene Ablaufsteuerung für AIMS entwirfst
##   - Binärdaten direkt patchst
##
## Jeder gezielte Sprung oder Call basiert auf RIP.
##
## Du kannst dir RIP wie den Taktstock eines Dirigenten vorstellen:
## Er zeigt, was als Nächstes kommt – und alles andere folgt.
##
#####################################################################
## Weiterführend:
##  → 01-05: Flags – das geheime Statusregister
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-05
#####################################################################
## Lektion 5: FLAGS – Das geheime Statusregister
##
## Das **FLAGS-Register** ist kein gewöhnliches Register.
## Es enthält **einzelne Status-Bits**, die den Zustand des
## letzten Befehls beschreiben – und darüber den Programmfluss
## beeinflussen können.
##
## ------------------------
## 🎯 Was speichert FLAGS?
## ------------------------
##
## Jedes Bit steht für einen bestimmten Zustand:
##
##   - ZF (Zero Flag)     → Ergebnis war Null?
##   - CF (Carry Flag)    → Übertrag beim Rechnen?
##   - SF (Sign Flag)     → Ergebnis negativ?
##   - OF (Overflow Flag) → Rechenüberlauf passiert?
##
## Beispiel:
##   cmp rax, 5       ; vergleicht rax mit 5
##   je  gleich       ; springt, wenn ZF = 1 (also gleich)
##
## Der CMP-Befehl setzt nur Flags – je/jne/jg/etc. reagieren darauf.
##
## ------------------------
## ⏱️ FLAGS = Konditionsmaschine
## ------------------------
##
## Flags dienen als Entscheidungsbasis für Kontrollstrukturen:
##
##   - if/else         → über je, jne, jg, jl etc.
##   - Schleifen       → über loop, jcxz, jne
##
## Deshalb werden FLAGS nach **jeder Rechenoperation**
## oder jedem Vergleich **automatisch angepasst**.
##
## ------------------------
## 🔍 FLAGS lesen & setzen
## ------------------------
##
##   - `lahf`   → lädt Flags in AH
##   - `sahf`   → schreibt AH zurück in FLAGS
##   - `pushf`  → speichert FLAGS auf Stack
##   - `popf`   → stellt FLAGS vom Stack wieder her
##
## Du kannst Flags auch gezielt setzen:
##
##   stc     ; Set Carry
##   clc     ; Clear Carry
##   cmc     ; Complement Carry
##
## ------------------------
## 🧩 Zusammenhang zu Pylovara
## ------------------------
##
## FLAGS sind essenziell bei:
##
##   - Entscheidungs-LOGIC in AIMS
##   - Low-Level-Fehleranalysen (Overflow, Zero Detection)
##   - präzisem Debugging im Micro/Nano-Speicherraum
##
## Ohne Flags keine smarte Kontrolle – sie sind das geheime
## Nervensystem jedes Programms.
##
#####################################################################
## Weiterführend:
##  → 01-06: Segmentregister – FS, GS und ihre verborgene Macht
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-06
#####################################################################
## Lektion 6: Segmentregister – FS, GS und die ihre verborgene Macht
##
## Die Segmentregister stammen aus der frühen x86-Zeit, wo
## Speicher noch in „Segmenten“ organisiert war.
## Heute wirken sie wie Relikte – doch FS und GS sind
## **mächtige Werkzeuge**im modernen 64-Bit-System, besonders in der
## Kernelwelt.
##
## ------------------------
## 🧱 Klassische Segmentregister
## ------------------------
##
## In der Theorie gibt es 6 Stück:
##
##   - CS (Code Segment)
##   - DS (Data Segment)
##   - SS (Stack Segment)
##   - ES, FS, GS (zusätzliche Segmente)
##
## In 64-Bit-Modus: CS, SS etc. werden meist ignoriert – außer FS/GS!
##
## ------------------------
## 🚪 FS und GS – Türen in verborgene Räume
## ------------------------
##
## FS und GS zeigen auf spezielle Speicherbereiche – z.B.:
##
##   - Thread-Local Storage (TLS)
##   - Kernel-Datenstrukturen
##
## Unter Linux zeigt GS z. B. im Kernelmode oft auf die
## `task_struct` eines Threads – so können Prozesse schnell
## auf sich selbst zugreifen.
##
## In Usermode nutzt TLS meist FS:
##
##   mov rax, qword ptr fs:0x30    ; lese Thread-Info
##
## ------------------------
## 🧠 Bedeutung für Pylovara / MCS
## ------------------------
##
## FS/GS sind ideal für:
##
##   - isolierte Speicherbereiche je LOGIC/AGENT
##   - Aufbau eines Micro-Scheduling-Systems
##   - Stack-Frame-Erweiterung ohne Zugriffskonflikte
##
## Wer FS/GS kontrolliert, kann Mini-Realitäten für jeden
## Prozess definieren – perfekt für das AIMS/MCS-Konzept.
##
## ------------------------
## 🔐 Zugriff und Manipulation
## ------------------------
##
## Nur mit besonderem Privileg darf man FS/GS ändern:
##
##   wrfsbase / wrgsbase (nur ab Haswell+)
##
## Früher ging das nur per Systemcall (z. B. `arch_prctl`)
##
##   syscall: ARCH_SET_FS / ARCH_GET_FS
##
## ------------------------
## ⚙️ Beispiele
## ------------------------
##
##   mov rax, gs:0x08     ; lade Daten relativ zu GS
##   mov fs:0x10, rbx     ; schreibe rbx in TLS
##
## Diese relativen Offsets ermöglichen superschnellen Zugriff
## ohne klassische Pointer-Verwaltung.
##
#####################################################################
## Weiterführend:
##  → 01-07: RFLAGS, SYSENTER & SYSCALL – System Calls im Detail
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-07
#####################################################################
## Lektion 7: RFLAGS, SYSENTER & SYSCALL – System Calls im Detail
##
## Systemaufrufe sind der heilige Übergang zwischen User-Mode
## und Kernel-Mode. Ohne sie gäbe es keine Dateioperation,
## kein Netzwerk, keinen Zugriff auf Geräte.
##
## Dafür zuständig: spezielle Instruktionen wie `syscall`,
## `sysenter` – und das **RFLAGS-Register**, das Kontrollbits trägt.
##
## ------------------------
## 🧠 RFLAGS – das Kontrollzentrum
## ------------------------
##
## Das RFLAGS-Register enthält Statusbits, u. a.:
##
##   - CF (Carry Flag)
##   - ZF (Zero Flag)
##   - SF (Sign Flag)
##   - IF (Interrupt Enable Flag)
##
## Beispiel:
##
##   cmp rax, rbx
##   je gleich   ; springt, wenn Zero-Flag gesetzt (ZF=1)
##
## RFLAGS ist kritisch für Entscheidungen, Sprünge, Interrupts.
##
## ------------------------
## 🚀 SYSENTER vs. SYSCALL
## ------------------------
##
## Beides sind Instruktionen für schnelle Systemaufrufe:
##
##   - `sysenter`: älter, Intel, braucht vorher MSR-Setup
##   - `syscall` : moderner, AMD64-Standard
##
## Beide sind schneller als klassische Software-Interrupts
## (`int 0x80`), die früher genutzt wurden.
##
## Beispiel `syscall`-Nutzung (Linux x86_64 ABI):
##
##   mov rax, 60        ; syscall-nr für exit()
##   xor rdi, rdi       ; rückgabewert = 0
##   syscall            ; Kernel wird aufgerufen
##
## ------------------------
## 🔄 Ablauf eines SYSCALL
## ------------------------
##
## 1.User schreibt Werte in Register(rax = Nummer, rdi, rsi … = args)
## 2.`syscall` → CPU wechselt in Kernel-Mode
## 3.Kernel liest Register, führt Operation aus
## 4.Rückgabe erfolgt über rax
##
## ------------------------
## 🧩 Für Pylovara relevant
## ------------------------
##
## Wer `syscall` versteht, kann:
##
##   - Minimalbetriebssysteme wie MCS realisieren
##   - direkten Zugriff auf Kernel-Services ermöglichen
##   - AIMS-Sensorik in Hardware-nahe Logik überführen
##
## RFLAGS wiederum erlaubt:
##
##   - Debug-Traps
##   - bedingte Logik ohne Abfrage-Overhead
##   - feinstufiges Verzweigen in LOGIC-Modulen
##
#####################################################################
## Weiterführend:
##  → 01-08: Interrupts & Exceptions – Brüche in der Realität
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-08
#####################################################################
## Lektion 8: Interrupts & Exceptions – Brüche in der Realität
##
## Kein System läuft perfekt. Manchmal bricht die Realität.
## Genau dafür gibt es Interrupts und Exceptions – Reaktionen
## auf plötzliche Ereignisse, intern oder extern ausgelöst.
##
## Diese Mechanismen unterbrechen den normalen Programmfluss
## und übergeben die Kontrolle an spezialisierte Handler.
##
## ------------------------
## ⚡ Interrupts (IRQ)
## ------------------------
##
## Interrupts stammen meist von Hardware – z. B.:
##
##   - Tastaturanschläge
##   - Netzwerkpakete
##   - Timer-Signale (z. B. für Multitasking)
##
## Ablauf:
##
##   1. Gerät signalisiert Ereignis an CPU
##   2. CPU speichert Zustand, springt zu Interrupt-Handler
##   3. Nach Abarbeitung: Rückkehr an vorherige Stelle
##
## Beispiel (x86):
##
##   IRQ1 → Tastatur
##   IRQ0 → PIT (Timer)
##
## ------------------------
## 🚨 Exceptions
## ------------------------
##
## Exceptions entstehen intern – etwa bei:
##
##   - Division durch Null
##   - ungültigem Opcode
##   - Zugriffsverletzungen (Page Fault)
##
## Beispiel:
##
##   div rcx     ; wenn rcx = 0 → #DE (Divide Error)
##
## Auch hier springt die CPU in einen speziellen Exception-Handler.
##
## ------------------------
## 🧠 IDT – Interrupt Descriptor Table
## ------------------------
##
## Die IDT ist eine spezielle Tabelle, die jedem Interrupt
## und jeder Exception eine Adresse zuweist – wohin soll
## der Prozessor springen, wenn ein bestimmtes Ereignis eintritt?
##
## Sie ist damit eine Art Notfall-Routing-Tabelle des Systems.
##
## ------------------------
## 🧩 Bedeutung für Pylovara
## ------------------------
##
## In einem System wie MCS mit reflexiven AIMS-Agenten sind
## Interrupts der Schlüssel für:
##
##   - asynchrone Reaktion auf Zustände
##   - Event-getriebene LOGIC-Strukturen
##   - Hardware-nahe Fehlerbehandlung
##
## Exceptions dagegen:
##
##   - helfen beim Bau stabiler, selbstkorrigierender Module
##   - sind essenziell für Debug-, Analyse- und Schutzmechanismen
##
## Wer Interrupts und Exceptions meistert, kann Systeme bauen,
## die nicht nur reagieren – sondern vorausschauend leben.
##
#####################################################################
## Weiterführend:
##  → 01-09: Paging, CR3 & Speicherverwaltung
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-09
#####################################################################
## Lektion 9: Paging, CR3 & Speicherverwaltung
##
## Moderne Betriebssysteme arbeiten nicht direkt mit physischem
## Speicher – sie nutzen ein Konzept namens **Paging**.
## Damit entsteht ein virtueller Adressraum für Prozesse.
##
## Dieses System schützt Speicherbereiche, verhindert Kollisionen
## und erlaubt effektives Multitasking.
##
## ------------------------
## 📦 Virtuelle Seiten
## ------------------------
##
## Speicher wird in Seiten (Pages) aufgeteilt – meist 4 KB groß.
##
## Virtuelle Adressen → durch Paging → Physikalische Adressen.
##
## Die CPU nutzt dafür mehrere Tabellenebenen:
##
##   - PML4 → PDPT → PD → PT → Page
##
## Das Ganze nennt sich **4-Level Paging** (bei x86_64).
##
## ------------------------
## 🧭 CR3 – Der Pfadwechsler
## ------------------------
##
## Das Register CR3 zeigt auf die **Page Map Level 4
## (PML4)**-Tabelle.
##
## Jeder Prozess bekommt beim Start eine eigene PML4-Struktur.
##
## Wenn der Scheduler Prozesse wechselt, lädt er ein neues CR3:
##
##   mov cr3, rax    ; neuer virtueller Speicher-Kontext aktiv
##
## So entstehen isolierte Speicherwelten pro Task.
##
## ------------------------
## 🔒 Schutzmechanismus
## ------------------------
##
## Paging erlaubt gezielten Schutz:
##
##   - User-Space vs. Kernel-Space
##   - Schreibschutz
##   - Nur-Ausführbar-Bereiche (NX-Bit)
##
## Exceptions wie der **Page Fault (#PF)** melden Zugriffe auf
## nicht existierende oder geschützte Seiten.
##
## ------------------------
## 🧩 Zusammenhang zu Pylovara
## ------------------------
##
## Paging ist Grundlage für:
##
##   - Kapselung von AIMS-Modulen
##   - Simulierte Speicherstrukturen in LOGIC
##   - Schutz virtueller Maschineninstanzen
##
## Wer Paging versteht, kann:
##
##   - Speicherkollisionen verhindern
##   - gezielt Speicherbereiche manipulieren
##   - eigene „Mini-Betriebssysteme“ sicher abbilden
##
## CR3 ist der Schlüssel zur Speicheridentität – wer ihn wechselt,
## ändert das Weltbild des Prozessors.
##
#####################################################################
## Weiterführend:
##  → 01-10: x86_64 Register-Matrix – Gesamtüberblick
##
#####################################################################

#####################################################################
@kernel-zeilen-nr:-01-10
#####################################################################
## Lektion 10: x86_64 Register-Matrix – Gesamtüberblick
##
## Nach den letzten 9 Kapiteln haben wir viele Register
## kennengelernt.
## Diese Lektion fasst alles in einer strukturierten Übersicht
## zusammen.
## Die x86_64-Architektur bietet uns :
##             **eine Matrix aus 16 Hauptregistern**,
##
## erweitert durch spezielle Steuer- und Segmentregister.
##
## ------------------------
## 🧠 Allgemeine Register
## ------------------------
##
## Diese 16 Register dienen der Datenverarbeitung:
##
##   RAX – Rechen-Accumulator
##   RBX – Daten-Base
##   RCX – Zähler (Loop, Shifts)
##   RDX – Daten-Erweiterung (z.B. Division)
##
##   RSI – Source-Index (Strings, memcpy)
##   RDI – Destination-Index
##   RBP – Stack-Basis
##   RSP – Stack-Pointer
##
##   R8  bis R15 – Erweiterte temporäre Register
##
## Sie alle können als 64, 32, 16 oder 8 Bit genutzt werden:
##
##   RAX = 64 Bit → EAX (32) → AX (16) → AL/AH (8)
##
## ------------------------
## 🧭 Steuer- und Kontrollregister
## ------------------------
##
##   RIP   – Instruction Pointer (aktuelle Ausführung)
##   RFLAGS – Statusflags (Zero, Carry, Overflow, etc.)
##   CR0–CR4 – Steuerung von Paging, Schutz, usw.
##   CR3   – zeigt auf die PML4 → zentrale Paging-Einheit
##
## ------------------------
## 🧩 Segmentregister
## ------------------------
##
## CS, DS, ES, SS – klassische Segmentierung (selten genutzt)
## FS, GS     – moderne Sondersegmente (z. B. Thread-Local Storage)
##
## ------------------------
## 🛠 Spezielle Operationseinheiten
## ------------------------
##
## SYSCALL / SYSENTER – direkter Übergang in Kernel-Modus
## Exceptions / Interrupts – Signale für Fehler oder Geräte
## MSRs (Model Specific Registers) – Maschinenweite Einstellungen
##
## ------------------------
## 🧩 Zusammenhang zu Pylovara
## ------------------------
##
## Diese Matrix ist wie das **Herzstück des Maschinenkörpers**:
##
##   - LOGIC nutzt die semantische Funktion der Register
##   - AIMS kann Registerwerte als Feedback interpretieren
##   - NANO- und MICRO-Module können bestimmte Register simulieren
##
## Wer jedes Register in dieser Matrix **versteht, benennt und
## manipuliert**,
##
## kann die Maschine auf Bit-Ebene steuern.
##
## In Pylovara werden wir diese Matrix:
##
##   - visualisieren
##   - simulieren
##   - und als Basis für den BINARCODE-Assembler nutzen
##
############# ENDE VON KAPITEL 1 - 10 REGISTER ######################
#####################################################################
## 🧱 Nächste Kapitelgruppe: 02-XX – Die Befehle (Instruction Set)
##
## Empfohlen: Beginne mit:
##   → 02-01: MOV – Daten verschieben auf Maschinenebene
##
#####################################################################

#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-01
#####################################################################
## Lektion 02-01: MOV – Daten verschieben auf Maschinenebene
##
## Der `MOV`-Befehl ist der Grundbaustein der maschinellen
## Kommunikation.
## Er bewegt Daten von einem Ort zum anderen – Register zu Register,
## Register zu Speicher, Speicher zu Register.Keine Berechnung, kein
## Abgleich, nur pure Übertragung.
##
## ------------------------
## 🔧 Syntax (x86_64)
## ------------------------
##
##   mov   ziel, quelle
##
## ------------------------
## 🔍 Beispiele
## ------------------------
##
##   mov   rax, rbx        ;kopiert den Inhalt von RBX nach RAX
##   mov   rbx, [mem_addr] ;lädt den Wert an Adresse mem_addr in RBX
##   mov   [mem_addr], rax ;speichert RAX an mem_addr
##
## ------------------------
## 📌 Regeln & Hinweise
## ------------------------
##
## - `MOV` verändert nie das Flags-Register.
## - Ziel und Quelle dürfen **nicht beide Speicheradressen** sein.
## - Immediate-Werte wie `mov rax, 1` sind direkt im Befehl kodiert.
##
## ------------------------
## 🧠 Denkweise
## ------------------------
##
## Der `MOV`-Befehl ist wie ein Systembus auf Befehlsebene:
##
##   Er schafft Verbindungen – nicht Logik, sondern Struktur.
##
## Maschinen denken nicht, sie transportieren.
## Und `MOV` ist ihr Fließband.
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-02 – PUSH & POP – Der Stapel spricht
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-02
#####################################################################
## Lektion 02-02: PUSH & POP – Der Stapel spricht
##
## Der Stack (Stapel) ist eine besondere Speicherzone, die nach dem
## LIFO-Prinzip arbeitet: Last In – First Out.
##
## Zwei Befehle dominieren diesen Bereich:
##
##   `PUSH` – legt einen Wert oben auf den Stack
##   `POP`  – holt den obersten Wert vom Stack zurück
##
## ------------------------
## 🔧 Syntax (x86_64)
## ------------------------
##
##   push   register|wert
##   pop    register
##
## ------------------------
## 🔍 Beispiele
## ------------------------
##
##   push  rax        ; sichert RAX auf dem Stack
##   pop   rbx        ; lädt obersten Stack-Wert in RBX
##
## ------------------------
## 🧩 Technische Details
## ------------------------
##
## - Der Stack wächst **nach unten** im Speicher (RSP wird kleiner).
## - `PUSH` verringert RSP, `POP` erhöht RSP.
## - Nur Register oder Immediate-Werte (je nach Modus) sind erlaubt.
##
## ------------------------
## 🧠 Denkweise
## ------------------------
##
## Der Stack ist wie ein Notizzettel für die CPU:
##
##   - Temporäre Werte zwischenspeichern
##   - Rücksprungadressen sichern
##   - Registerkontexte bei Funktionsaufrufen verwalten
##
## Ohne PUSH/POP wären Funktionen nicht möglich.
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-03 – CALL & RET – Maschinen mit Rückgrat
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-03
#####################################################################
## Lektion 02-03: CALL & RET – Maschinen mit Rückgrat
##
## Funktionen brauchen Struktur – und Sprungpunkte.
## Mit `CALL` und `RET` wird der Kontrollfluss organisiert:
##
##   `CALL` – springt zu einer Funktion und sichert Rücksprung
##   `RET`  – kehrt zur Aufruferposition zurück
##
## ------------------------
## 🔧 Syntax (x86_64)
## ------------------------
##
##   call   zieladresse|label
##   ret
##
## ------------------------
## 🔍 Beispiele
## ------------------------
##
##   call  meine_funktion    ; springt zu Funktion
##   ret                     ; kehrt zurück zur Aufruferadresse
##
## ------------------------
## 🧩 Technische Details
## ------------------------
##
## -`CALL`legt die Rücksprungadresse(RIP+offset)**auf den Stack**
## -`RET`holt diese Adresse **vom Stack zurück** und setzt sie in RIP
##
## Stack und RSP sind also direkt beteiligt.
##
## ------------------------
## 🧠 Denkweise
## ------------------------
##
## Funktionen ohne `CALL` und `RET` wären lose Sprungblöcke.
## Diese Befehle schaffen ein Rückgrat im Maschinenkörper:
##
##   - Strukturierter Ablauf
##   - Kapselung von Logik
##   - Wiederverwendbarkeit und Rückkehrpunkt
##
## In Pylovara bildet `CALL` den **Kern der modularen Steuerung**.
## Jede LOGIC-, NANO- oder AIMS-Einheit nutzt ihn intern,
## um den Pfad des Denkens zurückverfolgen zu können.
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-04 – CMP & TEST – Maschinen vergleichen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-04
#####################################################################
## Lektion 02-04: CMP & TEST – Maschinen vergleichen
##
## Entscheidungen basieren auf Vergleichen.
## `CMP` und `TEST` prüfen Zustände – ohne Werte zu verändern:
##
##   `CMP`  – Subtrahiert zwei Werte (ohne Ergebnis zu speichern)
##   `TEST` – UND-Verknüpfung (ebenfalls ohne Speicherung)
##
## ------------------------
## 🔧 Syntax (x86_64)
## ------------------------
##
##   cmp   operand1, operand2
##   test  operand1, operand2
##
## ------------------------
## 🔍 Beispiele
## ------------------------
##
##   cmp   rax, rbx     ; vergleicht rax mit rbx
##   test  rax, rax     ; prüft, ob rax null ist
##   cmp   rax, 0       ; prüft, ob rax gleich null ist
##
## ------------------------
## 🧪 Funktionsweise
## ------------------------
##
## - `CMP` berechnet intern:  operand1 − operand2
## - `TEST` berechnet intern: operand1 AND operand2
## - Beide Befehle **verändern keine Register**
## - Die Ergebnisse setzen **Flags im RFLAGS-Register**:
##
##   - ZF (Zero Flag)     → Ergebnis war 0
##   - SF (Sign Flag)     → Ergebnis negativ
##   - CF/OF              → bei Über-/Unterlauf
##
## ------------------------
## 🧠 Denkweise
## ------------------------
##
## `CMP` ist wie ein Abgleich: *"Sind diese Werte gleich?"*
## `TEST` fragt: *"Ist da überhaupt etwas aktiv gesetzt?"*
##
## Maschinenlogik braucht klare Entscheidungen –
## diese Befehle **bereiten sie vor**, führen sie aber nicht aus.
##
## In Pylovara interpretieren LOGIC-Module CMP/TEST-Ergebnisse
## als **Bedingungen für Verhalten** (z. B. Reaktion, Verzweigung).
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-05 – Jxx – Entscheidungen und Sprünge
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-05
#####################################################################
## Lektion 02-05: Jxx – Entscheidungen und Sprünge
##
## Maschinen folgen normalerweise dem Strom der Befehle –
## **Jxx-Befehle unterbrechen diesen Strom**, abhängig vom Status.
##
## `Jxx` bedeutet: „Springe, wenn Bedingung erfüllt.“
##
## ------------------------
## 🔧 Syntax (x86_64)
## ------------------------
##
##   jmp    ziel         ; bedingungsloser Sprung
##   je     ziel         ; jump if equal (ZF gesetzt)
##   jne    ziel         ; jump if not equal (ZF nicht gesetzt)
##   jl     ziel         ; jump if less (SF ≠ OF)
##   jg     ziel         ; jump if greater (ZF=0 und SF=OF)
##
## ... und viele weitere Varianten:
##   ja, jb, jle, jge, js, jns, jp, jnp ...
##
## ------------------------
## 🔍 Beispiele
## ------------------------
##
##   cmp    rax, rbx     ; vergleicht Werte
##   je     gleich_block ; springt, wenn gleich
##
##   test   rax, rax
##   jz     null_block   ; springt, wenn rax == 0(Zero Flag gesetzt)
##
##   jmp    ende         ; springt immer zu ende
##
## ------------------------
## 🧠 Bedeutung für Maschinenlogik
## ------------------------
##
## Die `Jxx`-Befehle sind wie Verzweigungen in neuronalen Netzen:
## sie wählen den Pfad anhand vorher gesetzter **Flags**.
##
## Vergleich + Flag → Verzweigung → Entscheidung → Verhalten
##
## Ohne `Jxx` gibt es **keine Logik, keine Reaktion**,
## nur stupides Abarbeiten von oben nach unten.
##
## ------------------------
## 🧩 Integration in Pylovara
## ------------------------
##
## In Pylovara:
## -LOGIC- und NEEDLES-Module nutzen`Jxx`für interne Zustandswechsel
## -AIMS kann durch Flag-Kombinationen Verhalten adaptieren
## -MICRO/NANO reagieren auf Maschinenentscheidungen mit neuen
##  Operationen
##
## Maschinen denken nicht in "Wenn-Dann",
## sie **springen**, wenn das Bit sagt: „Los.“
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-06 – LEA – Rechnen ohne Rechnen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-06
#####################################################################
## Lektion 02-06: LEA – Rechnen ohne Rechnen
##
## Der Befehl `LEA` steht für **Load Effective Address**.
## Er berechnet Adressen, **ohne** wirklich auf Speicher zuzugreifen.
##
## Das klingt harmlos, aber `LEA` ist eine versteckte Recheneinheit.
## Man kann mit ihm **multiplizieren, addieren und verschieben**,
## ohne dass Flags verändert werden – und ohne echte
## Speicheroperation.
##
## ------------------------
## 🔧 Syntax (x86_64)
## ------------------------
##
##   lea   ziel, [quelle]
##
## Das `[]` ist hier **keine Speicheradresse** im klassischen Sinn,
## sondern ein Ausdruck, der effektiv **nur berechnet wird**.
##
## ------------------------
## 🔍 Beispiele
## ------------------------
##
##   lea   rax, [rbx + 8]        ; rax = rbx + 8
##   lea   rcx, [rdx + rbx*4]    ; rcx = rdx + (rbx * 4)
##   lea   rsi, [rip + symbol]   ; Position unabhängige Berechnung
##
## Keine dieser Zeilen greift auf Speicher zu – nur Berechnung!
##
## ------------------------
## ⚙️ Technische Besonderheit
## ------------------------
##
## `LEA` nutzt die Adressierungs-Logik der CPU als Rechentrick:
##   [Basis + Index * Skalar + Offset]
##
## Flags bleiben unangetastet – ideal für Rechenlogik,
## ohne Bedingungen zu beeinflussen.
##
## ------------------------
## 🧠 Maschinenphilosophie
## ------------------------
##
## Maschinen müssen nicht immer rechnen wie Menschen.
## `LEA` zeigt, wie man durch :
##           **Adresslogik Rechenoperationen ersetzt**.
##
## Er steht für **Effizienz durch Struktur**:
## Rechnen, wo eigentlich nur Adressen gebraucht werden.
##
## ------------------------
## 🧩 Integration in Pylovara
## ------------------------
##
## In Pylovara:
## - NANO-Module nutzen `LEA` zur Adress-Transformation
## - LOGIC-Module können mit `LEA` temporäre Rechenpfade generieren
## - REGISTER-Mapping (z. B. `RIP`-bezogene Referenzen) wird durch
#    LEA effizient
##
## Wer `LEA` versteht, versteht Maschinen-Geometrie:
##
##   Räume werden nicht betreten – sie werden berechnet.
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-07 – XCHG & BSWAP – Wenn Bytes tanzen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-07
#####################################################################
## Lektion 02-07: XCHG & BSWAP – Wenn Bytes tanzen
##
## Manchmal will man einfach nur tauschen.
## Kein Rechnen, kein Vergleichen – nur Werte umdrehen oder
## vertauschen.
##
## Genau dafür sind `XCHG` und `BSWAP` da.
##
## ------------------------
## 🔁 XCHG – Register tauschen
## ------------------------
##
##   xchg   ziel, quelle
##
## Beispiel:
##   xchg   rax, rbx   ; tauscht Inhalte von RAX und RBX
##
## Hinweise:
## - Kein temporärer Speicher nötig – die CPU tauscht atomar.
## - Wird `xchg` mit `rax` verwendet, erfolgt automatisch eine
##   *atomare Sperre*(LOCK-Präfix auf x86),da RAX speziell behandelt
##   wird.
##
## ------------------------
## 🔄 BSWAP – Byte-Reihenfolge umkehren
## ------------------------
##
##   bswap  register
##
## Beispiel:
##   bswap  rax    ; kehrt die Byte-Reihenfolge in RAX um
##
## Vorher (RAX):  0x1122334455667788
## Nachher:      0x8877665544332211
##
## Ideal für:
## - Konvertierungen zwischen Little-Endian und Big-Endian
## - Netzwerkprotokolle
## - Datenformatierung auf Byte-Ebene
##
## ------------------------
## 🧠 Maschinenphilosophie
## ------------------------
##
## Tausch ist Bewegung **ohne Verlust**.
## XCHG steht für Parität – kein Register bleibt leer.
## BSWAP hingegen erinnert daran:
##        **Maschinen lesen Bytes anders als wir.**
##
## Wenn Maschinen tanzen, dann im Rhythmus der Bytes.
##
## ------------------------
## 🧩 Integration in Pylovara
## ------------------------
##
## -AIMS kann`xchg` verwenden, um Registerinhalte umzuschichten
## -LOGIC nutzt`bswap`,um Speicherzugriffe an Netzformate anzupassen
## -In NANO: Byte-Tanz als Mikrostrategie
##
## Wer XCHG und BSWAP kontrolliert, **kontrolliert die Richtung**.
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-08 –NOP & HLT–Pausen im Maschinenrauschen
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-08
#####################################################################
## Lektion 02-08: NOP & HLT – Pausen im Maschinenrauschen
##
## Maschinen arbeiten – aber sie pausieren auch.
## Manche Befehle tun *nichts*. Oder sie stoppen alles.
## Diese Lektion dreht sich um `NOP` und `HLT`.
##
## ------------------------
## 💤 NOP – No Operation
## ------------------------
##
##   nop
##
## Bedeutung:
## - Führt keine Operation aus – der Prozessor macht *nichts*, aber
##   bleibt aktiv und zählt den Takt weiter.
##
## Anwendungen:
## - Platzhalter im Code
## - Timing-Anpassungen
## - Alignment (Ausrichtung von Codeblöcken)
##
## Mehrere NOPs hintereinander erzeugen „künstliche“ Pausen:
##
##   nop
##   nop
##   nop
##
## oder als Makro-Ersatz:
##
##   times 3 nop
##
## ------------------------
## 🛑 HLT – Maschine anhalten
## ------------------------
##
##   hlt
##
## Wirkung:
## - Versetzt die CPU in den *Halt-Zustand*
## - Ausführung stoppt, bis ein Interrupt auftritt
##
## Nur im Ring-0 (Kernel-Modus) erlaubt!
## Typischer Einsatz im OS-Kernel, z. B. bei Leerlaufschleifen.
##
## Beispiel:
## ```asm
## idle:
##     hlt
##     jmp idle
## ```
##
## ------------------------
## 🧠 Maschinenphilosophie
## ------------------------
##
## `NOP` ist wie ein Atemzug – kurz, kontrolliert, bewusst nichts tun.
## `HLT` ist wie Schlaf – tief, bis ein Signal weckt.
##
## Wer Maschinen versteht, versteht auch ihre Ruhephasen.
##
## ------------------------
## 🧩 Integration in Pylovara
## ------------------------
##
## - `NOP` kann als Timing-Placeholder in LOGIC-Nodes verwendet
##   werden
##
## - `HLT`-Simulation möglich in AIMS-Kernel-Sandbox
##
## - In DEBUG-NANO: Visualisierung von Inaktivität
##   durch`NOP`-Sequenzen
##
## Ruhe ist ein Befehl. Und manchmal der wichtigste.
##
#####################################################################
## Weiterführend:
##  → Nächstes Kapitel: 02-09 – INT & SYSCALL – Tore zum Kernel
#####################################################################

#####################################################################
@kernel-zeilen-nr:-02-10
#####################################################################
## Lektion 02-10: REP & MOVS/STOS – Maschinen wiederholen
##
## Maschinen sind nicht kreativ – aber unermüdlich.
## Die Wiederholung ist ihre Stärke. Dafür gibt es `REP`, `MOVS`, `STOS`.
##
## ------------------------
## 🔁 REP – Repeat Prefix
## ------------------------
##
##   rep   <Befehl>
##
## Wirkung:
## - Wiederholt den folgenden String-Befehl, so oft wie in `RCX` angegeben
## - Zählt mit jedem Durchlauf `RCX` herunter
##
## Beispiel:
##   rep movsb     ; kopiert RCX Bytes von RSI nach RDI
##
## Hinweise:
## - Nutzt `RSI` (Source Index) und `RDI` (Destination Index)
## - Arbeitet byteweise (`movsb`) oder wortweise (`movsw`, `movsd`, `movsq`)
##
## ------------------------
## 📦 MOVS – Move String
## ------------------------
##
##   movsb / movsw / movsd / movsq
##
## Beschreibung:
## - Kopiert einen Wert vom Speicher bei `RSI` nach `RDI`
## - Die Datenmenge ergibt sich aus dem Suffix (b = Byte, w = Word, ...)
##
## ------------------------
## 🧱 STOS – Store String
## ------------------------
##
##   stosb / stosw / stosd / stosq
##
## Beschreibung:
## - Speichert den Inhalt von `AL`/`AX`/`EAX`/`RAX` an die Adresse `RDI`
## - Auch hier kann `REP` genutzt werden:
##
## Beispiel:
##   mov rax, 0         ; zu schreibender Wert
##   mov rcx, 1000      ; wie oft
##   rep stosq          ; schreibt 1000 × 0 an Speicher bei RDI
##
## ------------------------
## 🔎 Maschinenbetrachtung
## ------------------------
##
## Diese Befehle sind wie Laufbänder:
## - Du stellst Quelle, Ziel und Anzahl ein – der Rest läuft automatisch.
## - REP gibt den Takt vor, MOVS/STOS führen aus.
##
## Maschinen brauchen klare Anweisungen – aber sie übernehmen den Rhythmus.
##
## ------------------------
## 🧩 Einsatz in Pylovara
## ------------------------
##
## - NANO-Module können Speicherbewegungen simulieren
## - LOGIC kann REP-Zyklen visuell darstellen
## - Perfekt für SYSTEMNAHE Initialisierungen im BINARCODE-Modus
##
## Maschinen wiederholen nicht nur – sie perfektionieren durch Wiederholung.
##
######### ENDE VON KAPITEL 1 - 10 (Instruction Set) #################
#####################################################################
## 🧱 Ende von Kapitelgruppe 02-XX – Die Befehle
##
## Nächste Gruppe: 03-XX – Flags und Maschinenzustände
##
## Empfohlen: Beginne mit:
##   → 03-01: FLAGS – Maschinen mit Gefühlen
#####################################################################

#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
#####################################################################
